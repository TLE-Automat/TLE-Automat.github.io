<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XCPC解题报告索引</title>
    <url>/2023/10/07/XCPC%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="season-2022---2023">Season 2022 - 2023</h1>
<h2 id="icpc">ICPC</h2>
<h3 id="icpc2022-济南站">ICPC2022 济南站</h3>
<p><a
href="https://tle-automat.top/2023/10/07/ICPC2022%E6%B5%8E%E5%8D%97%E7%AB%99%20A.%20Tower/">A.
Tower</a></p>
<span id="more"></span>
<h2 id="ccpc">CCPC</h2>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>XCPC解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC2022济南站 A. Tower</title>
    <url>/2023/10/07/ICPC2022%E6%B5%8E%E5%8D%97%E7%AB%99%20A.%20Tower/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://codeforces.com/gym/104076/problem/A">https://codeforces.com/gym/104076/problem/A</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span
class="math inline">\(\{ a_n\}\)</span> ，移去其中长度为 <span
class="math inline">\(m\)</span>
的子序列，对于剩下的元素能进行如下三种操作（无顺序和次数限制）：</p>
<ul>
<li>加 <span class="math inline">\(1\)</span></li>
<li>减 <span class="math inline">\(1\)</span></li>
<li>除以 <span class="math inline">\(2\)</span> 并向下取整</li>
</ul>
<p>问最少进行多少次操作能把这些数变相同。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(1\le n \le 500 , 0 \le m &lt; n, 1\le
a_i \le 10^{9}\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p><img src="https://z1.ax1x.com/2023/10/07/pPjdQYQ.png" /></p>
<p><img src="https://z1.ax1x.com/2023/10/07/pPjd8ln.png" /></p>
<h2 id="参考代码">参考代码</h2>
<p><a
href="https://codeforces.com/gym/104076/submission/226616247">https://codeforces.com/gym/104076/submission/226616247</a></p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>XCPC解题报告</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>7,8月杂题选做</title>
    <url>/2023/07/18/7,8%E6%9C%88%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A/</url>
    <content><![CDATA[<h1 id="图论相关">图论相关</h1>
<h2 id="题目来源">题目来源</h2>
<p><a
href="https://atcoder.jp/contests/abc308/tasks/abc308_h">ABC308Ex</a></p>
<h2 id="题意">题意</h2>
<p>给定一张 <span class="math inline">\(n\)</span> 个点 <span
class="math inline">\(m\)</span>
条边的无向带权图，找到图中一个权值最小的 <span
class="math inline">\(\text{Q}\)</span> 。</p>
<p><span class="math inline">\(\text{Q}\)</span>
定义为一个环带上一条与这个环相连且不在环上的边。</p>
<p><span class="math inline">\(4\le n \le 300 , 4\le m \le
\frac{n(n-1)}{2}\)</span> 。</p>
<h2 id="思路">思路</h2>
<p>考虑枚举每一条边作为 <span class="math inline">\(\text{Q}\)</span>
的尾巴，然后把这条边删去，从这条边的一个端点跑一个单源最短路。然后再枚举两个点，能够轻松找到不经过这条边的一个最小环。</p>
<p>这样枚举尾巴的时间复杂度为 <span
class="math inline">\(O(n^2)\)</span> ，找最小环的时间复杂度为 <span
class="math inline">\(O(n^2)\)</span> ，总时间复杂度为 <span
class="math inline">\(O(n^4)\)</span> ，这是难以接受的。</p>
<p>考虑到一个环会占用一个点相连的两条边，最劣情况下尾巴也是第三小的边，所以我们第一步不需要枚举所有的边作为尾巴，只需要枚举每个点相连的前三小的边做尾巴即可。这样枚举尾巴的时间复杂度降为
<span class="math inline">\(O(n)\)</span> ，总时间复杂度降为 <span
class="math inline">\(O(n^3)\)</span> 。</p>
<span id="more"></span>
<h1 id="动态规划">动态规划</h1>
<h2 id="题目来源-1">题目来源</h2>
<p><a
href="https://codeforces.com/problemset/problem/626/F">CF626F</a></p>
<h2 id="题意-1">题意</h2>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的数列 <span
class="math inline">\(a\)</span> ，把 <span
class="math inline">\(a\)</span>
分成任意组，每组的<strong>不和谐度</strong>定义为该组内元组的最大值与最小值之差，求所有<strong>不和谐度</strong>之和不超过
<span class="math inline">\(m\)</span> 的分组方案数，对 <span
class="math inline">\(10^9 + 7\)</span> 取模。</p>
<p><span class="math inline">\(1 \le n \le 200 , 0 \le m \le 10^3 , 1
\le a_i \le 500\)</span> 。</p>
<h2 id="思路-1">思路</h2>
<p>由于<strong>不和谐度</strong>是最大值与最小值的差，乱找不好找，考虑对数列
<span class="math inline">\(a\)</span>
从小到大进行排序，然后依次考虑每个数的分组情况。</p>
<p>考虑设 <span class="math inline">\(f_{i,j,k}\)</span> 为选了前 <span
class="math inline">\(i\)</span> 个位置，有 <span
class="math inline">\(j\)</span> 个没有结束的组，当前选的总不和谐度为
<span class="math inline">\(k\)</span> 的方案数。</p>
<p>考虑若有一个组选了 <span class="math inline">\(a_{p_1} , a_{p_2} ,
\cdots, a_{p_n}\)</span> 这些元素，且 <span class="math inline">\(p_1
&lt; p_2 &lt; \cdots &lt; p_n\)</span> ，则不和谐度为 <span
class="math inline">\(a_{p_n} - a_{p_1}\)</span> 。</p>
<p>考虑到 <span class="math inline">\(a_{p_n} - a_{p_1} = (a_{p_n} -
a_{p_{n-1}}) + (a_{p_{n-1}} - a_{p_{n-2}}) + \cdots + (a_{p_2} -
a_{p_1})\)</span> ，所以每次向之前的某一组中加入 <span
class="math inline">\(a_{i + 1}\)</span> 这个元素时，所有的组都会被增加
<span class="math inline">\(a_{i + 1} - a_{i}\)</span>
的不和谐度，利用这个可以找到转移时 <span
class="math inline">\(k\)</span> 的增量。</p>
<p>再考虑转移的几种情况：</p>
<ul>
<li><p>当前点单独成组：<span class="math inline">\(f_{i + 1 , j , k + j
\times (a_{i + 1} - a_i)} \leftarrow f_{i,j,k}\)</span> 。</p></li>
<li><p>当前点加入一个组中，即不作为最大值，也不作为最小值：<span
class="math inline">\(f_{i + 1, j, k + j \times (a_{i+1} - a_{i})}
\leftarrow f_{i, j, k}\)</span> 。</p></li>
<li><p>当前点新开一个组，且作为最小值：<span class="math inline">\(f_{i
+ 1, j + 1 , k + j \times(a_{i + 1} - a_{i})} \leftarrow
f_{i,j,k}\)</span> 。</p></li>
<li><p>当前点结束一个组，且作为最大值：<span class="math inline">\(f_{i
+ 1, j - 1, k + j \times (a_{i+1}-a_{i})} \leftarrow f_{i,j,k}\)</span>
。</p></li>
</ul>
<p>复杂度可以做到 <span class="math inline">\(O(n^2 m)\)</span> 。</p>
<h2 id="题目来源-2">题目来源</h2>
<p><a
href="https://acjudge.com/d/algorithmbasics/p/773">acjudge#773</a></p>
<h2 id="题意-2">题意</h2>
<p>有 <span class="math inline">\(n\)</span> 个物品和四个盒子 <span
class="math inline">\(A,B,C,D\)</span> ，每个物品都有一个重量 <span
class="math inline">\(w_i\)</span>
，你需要将每个物品放入一个盒子中。</p>
<p>给定 <span class="math inline">\(k_1,k_2,k_3,k_4\)</span> ，设 <span
class="math inline">\(|X|\)</span> 表示 <span
class="math inline">\(X\)</span>
盒子内物品的总重，一个合法的装盒方案最终应当满足如下的条件：</p>
<p><span class="math display">\[
|A|+|B|\le k_1
\]</span></p>
<p><span class="math display">\[
|C|+|D|\le k_2
\]</span></p>
<p><span class="math display">\[
|A|+|C|\le k_3
\]</span></p>
<p><span class="math display">\[
|B|+|D|\le k_4
\]</span></p>
<p>求有多少种合法的装盒方案，答案对 <span
class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(1\le n \le 100 , 1 \le k_i \le
1000\)</span> 。</p>
<h2 id="思路-2">思路</h2>
<p>脑筋慢转弯题（bushi</p>
<p>最直接的思路就是一个四维的背包 <span
class="math inline">\(\text{dp}\)</span> ，设 <span
class="math inline">\(f_{i,a,b,c,d}\)</span> 表示前 <span
class="math inline">\(i\)</span> 件物品，<span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 总共放了 <span
class="math inline">\(a\)</span> ，<span
class="math inline">\(C\)</span> 和 <span
class="math inline">\(D\)</span> 总共放了 <span
class="math inline">\(b\)</span> ，<span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(C\)</span> 总共放了 <span
class="math inline">\(c\)</span> ， <span
class="math inline">\(B\)</span> 和 <span
class="math inline">\(D\)</span> 总共放了 <span
class="math inline">\(d\)</span>
，满足以上限制的总方案数。转移就考虑当前物品放入哪一个箱子。</p>
<p>发现四个盒子两两组合总共有 <span class="math inline">\(6\)</span>
种，但题目中只限制了 <span class="math inline">\(4\)</span>
种，于是找一下关系，不难发现前两个式子加起来是 <span
class="math inline">\(|A| + |B| + |C| + |D|\)</span>
，后两个式子加起来也是 <span class="math inline">\(|A| + |B| + |C| +
|D|\)</span> 。</p>
<p>设 <span class="math inline">\(w_i\)</span> 的前缀和是 <span
class="math inline">\(sum_i\)</span> ，那么到第 <span
class="math inline">\(i\)</span>
个位置，由于每个物品一定会被放入四个盒子其中之一，所以 <span
class="math inline">\(a + c = |A| + |B| + |C| + |D| = sum_i\)</span>
，<span class="math inline">\(b + d = |A| + |B| + |C| + |D| =
sum_i\)</span> ，所以我们找到了 <span class="math inline">\(a,c\)</span>
之间和 <span class="math inline">\(b,d\)</span>
之间的关系，这样可以压掉两维，时间复杂度变成了 <span
class="math inline">\(O(n k ^2)\)</span> 。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
</search>
