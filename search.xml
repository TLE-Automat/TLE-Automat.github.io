<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【目录】博客索引</title>
    <url>/2023/10/08/%E3%80%90%E7%9B%AE%E5%BD%95%E3%80%91/</url>
    <content><![CDATA[<p><strong>待施工ing</strong></p>
<span id="more"></span>
]]></content>
      <categories>
        <category>索引</category>
      </categories>
      <tags>
        <tag>QwQ</tag>
      </tags>
  </entry>
  <entry>
    <title>HashKiller——如何优雅地卡掉单模数哈希</title>
    <url>/2024/03/19/HashKiller%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%9C%B0%E5%8D%A1%E6%8E%89%E5%8D%95%E6%A8%A1%E6%95%B0%E5%93%88%E5%B8%8C/</url>
    <content><![CDATA[<h2 id="i.-起因">I. 起因</h2>
<p>之前打比赛多次担心写单哈希被卡，但 N
神之前说他高中打过的所有比赛，但凡是字符串的题写 unsigned long long
自然溢出从来没被卡过。我信以为真，认为现在已经没有人素质差到卡别人单模哈希。后来我打了一些
AtCoder 的比赛也写了很多 ull 自然溢出也没事。直到 <a
href="https://codeforces.com/contest/1943">这场CF</a> N 神 B 题 ull
自然溢出被卡到裂开，以为思路错了，直到赛后才发现是单哈希被卡了。</p>
<span id="more"></span>
<p>鉴于以上惨痛的经历，我决定学习一下毒瘤的卡单模数哈希的方法，来警示自己以及与
N
神心态类似的人：不要管出题人卡不卡，反正写双哈希就对了。<del>（警钟撅烂（逃</del></p>
<h2 id="ii.-模-109-级别的大质数哈希">II. 模 <span
class="math inline">\(10^9\)</span> 级别的大质数哈希</h2>
<p>其实单模 <span class="math inline">\(10^9\)</span>
级别的大质数哈希非常好卡，我们只需要随机一个长度为 <span
class="math inline">\(10^5\)</span> 级别的只包含小写字母的字符串 <span
class="math inline">\(s\)</span>，再任取一个大小为 <span
class="math inline">\(100\)</span> 左右的子串长度 <span
class="math inline">\(k\)</span>，那么 <span
class="math inline">\(s\)</span> 的所有长度为 <span
class="math inline">\(k\)</span>
的子串中大概率会存在哈希冲突的字符串。</p>
<p>那么概率到底有多大呢，我们可以使用<strong>生日悖论</strong>的方法来计算。</p>
<p>字符串 <span class="math inline">\(s\)</span> 的长度为 <span
class="math inline">\(k\)</span> 的子串总共有 <span
class="math inline">\(26^{k}\)</span> 种可能，当 <span
class="math inline">\(k = 100\)</span> 时 <span
class="math inline">\(s\)</span> 的任意两个长度为 <span
class="math inline">\(k\)</span>
的子串几乎不可能相等，所以我们按照长度为 <span
class="math inline">\(k\)</span>
的子串均不同来考虑。（其实计算这个本身也是生日悖论）</p>
<p>因为 <span class="math inline">\(s\)</span> 中总共有 <span
class="math inline">\(10^5 - k + 1\)</span> 个长度为 <span
class="math inline">\(k\)</span> 的子串，设 <span
class="math inline">\(p\)</span> 为模数，则第 <span
class="math inline">\(1\)</span> 个子串的哈希值不跟之前重复的概率为
<span class="math inline">\(\displaystyle{\frac{p}{p}}\)</span>，第
<span class="math inline">\(2\)</span>
个子串的哈希值不跟之前重复的概率为 <span
class="math inline">\(\displaystyle{\frac{p - 1}{p}}\)</span> ，第 <span
class="math inline">\(n\)</span> 个子串的哈希值不跟之前重复的概率为
<span class="math inline">\(\displaystyle{\frac{p - n +
1}{p}}\)</span>。所以出现至少两个长度为 <span
class="math inline">\(k\)</span> 子串哈希冲突的概率为 <span
class="math inline">\(\displaystyle{1 - \prod\limits_{i = 1}^{10^{5} - k
+ 1} \frac{p - i + 1}{p}}\)</span>。当 <span class="math inline">\(p =
10^9 + 7, k = 100\)</span> 时计算上式的值约为 <span
class="math inline">\(0.9931958400\)</span>。</p>
<p>根据以上结论，随便写个代码一随机就能找到两个哈希冲突的字符串，所以单模
<span class="math inline">\(10^9\)</span> 级别的哈希千万不要写。</p>
<h2 id="iii.-unsigned-long-long-自然溢出哈希">III. unsigned long long
自然溢出哈希</h2>
<p>由于样本空间是 <span class="math inline">\(10^{18}\)</span>
级别，非常大，直接采取<strong>生日悖论</strong>的方法难以卡掉。</p>
<p>其实我们用上面的方法算一下概率，取 <span class="math inline">\(p =
10^{18}\)</span>，<span class="math inline">\(|s| =
10^{6}\)</span>，<span class="math inline">\(k =
100\)</span>，哈希冲突的概率约为 <span
class="math inline">\(0.0000004999\)</span>。（这其实也为两个 <span
class="math inline">\(10^{9}\)</span>
级别大质数的双模哈希的正确性提供了证明。）</p>
<p>所以我们要换一套方法来卡，这里一般的方法为构造法。</p>
<h3 id="对于底数为偶数的情况">1. 对于底数为偶数的情况</h3>
<p>构造字符串 <code>baaa...</code>（后面有 <span
class="math inline">\(64\)</span> 个 <code>a</code>）与
<code>caaa...</code>（后面有 <span class="math inline">\(64\)</span> 个
<code>a</code>）即可卡掉。</p>
<p>这两个字符串的后 <span class="math inline">\(64\)</span>​ 个字符均为
<code>a</code>，所以只需要关心第 <span class="math inline">\(1\)</span>
个位置对哈希值的贡献。</p>
<p>对于第一个字符串，第 <span class="math inline">\(1\)</span>
个位置对哈希值的贡献为 <span
class="math inline">\(H(\text{&quot;b&quot;}) \times Base^{64} \bmod
2^{64}\)</span>。</p>
<p>对于第二个字符串，第 <span class="math inline">\(1\)</span>
个位置对哈希值的贡献为 <span
class="math inline">\(H(\text{&quot;a&quot;}) \times Base^{64} \bmod
2^{64}\)</span>。</p>
<p>因为 <span class="math inline">\(Base\)</span> 为偶数，所以 <span
class="math inline">\(Base\)</span> 中至少含有一个因子 <span
class="math inline">\(2\)</span>，所以 <span
class="math inline">\(2^{64} \mid Base^{64}\)</span>，所以两个字符串的第
<span class="math inline">\(1\)</span> 个位置对哈希值的贡献均为 <span
class="math inline">\(0\)</span>，所以两字符串哈希冲突。</p>
<h3 id="对于底数为奇数的情况">2. 对于底数为奇数的情况</h3>
<p>考虑进行如下构造：</p>
<ul>
<li>定义 <span class="math inline">\(S_1 =
\text{&quot;a&quot;}\)</span></li>
<li>令 <span class="math inline">\(\text{len}(S_i)\)</span> 表示字符串
<span class="math inline">\(S_i\)</span> 的长度</li>
<li>令 <span class="math inline">\(\text{not}(T)\)</span> 为将字符串
<span class="math inline">\(T\)</span> 中字符 <span
class="math inline">\(\text{&quot;a&quot;}\)</span> 变为字符 <span
class="math inline">\(\text{&quot;b&quot;}\)</span>，字符 <span
class="math inline">\(\text{&quot;b&quot;}\)</span> 变为字符 <span
class="math inline">\(\text{&quot;a&quot;}\)</span> 的函数</li>
<li><span class="math inline">\(S_i = S_{i - 1} + \text{not}(S_{i -
1})\)</span></li>
</ul>
可以推导出 <span class="math inline">\(\text{len}(S_i) = 2^{i -
1}\)</span>，且 $$
<span class="math display">\[\begin{aligned}

&amp;H(S_i) = H(S_{i - 1}) \times Base^{2^{i - 1}} + H(\text{not}(S_{i -
1})) \\

&amp;H(\text{not}(S_i)) = H(\text{not}(S_{i - 1})) \times Base^{2^{i -
1}} + H(S_{i - 1})

\end{aligned}\]</span>
<p><span class="math display">\[
令 $f_i = H(S_i) - H(\text{not}(S_{i - 1}))$，上述两式相减，可得
\]</span> f_{i} = f_{i - 1} (Base<sup>{2</sup>{i-1}} - 1) $$ 当 <span
class="math inline">\(f_i \bmod 2^{64} = 0\)</span>
时，我们即可构造出两个哈希冲突的字符串。</p>
<p>注意到 <span class="math inline">\(Base\)</span> 为奇数，所以 <span
class="math inline">\(Base^{2^{i - 1}} - 1\)</span> 必定为偶数。所以
<span class="math inline">\(f_{64} \bmod 2^{64}\)</span> 必定为 <span
class="math inline">\(0\)</span>，但是这要构造出两个长度为 <span
class="math inline">\(2^{63}\)</span> 的字符串 <span
class="math inline">\(S_{64}\)</span> 和 <span
class="math inline">\(\text{not}(S_{64})\)</span>，理论上这两个串是哈希冲突的，但是因为长度太长，现实中显然无法进行读写。</p>
<p>注意到 <span class="math inline">\((Base^{2^{i - 1}} - 1) =
(Base^{2^{i - 2}} + 1)(Base^{2^{i-2}} - 1) = (Base^{2^{i - 2}} +
1)(Base^{2^{i - 3}} + 1) \cdots (Base^{2^{1}} + 1)(Base^{2^{1}} -
1)\)</span>。容易证明，上述的每一项都是偶数，所以 <span
class="math inline">\(f_i\)</span> 中至少含有 <span
class="math inline">\((i - 1) + (i - 2) + \cdots + 1 =
\displaystyle{\frac{(i - 1)i}{2}}\)</span> 个因子 <span
class="math inline">\(2\)</span>。</p>
<p>由上述理论进行计算，<span class="math inline">\(f_{12}\)</span>
中至少含有 <span class="math inline">\(66\)</span> 个因子 <span
class="math inline">\(2\)</span>，所以 <span
class="math inline">\(S_{12}\)</span> 与 <span
class="math inline">\(\text{not}(S_{12})\)</span> 哈希冲突，长度仅为
<span class="math inline">\(2^{11}\)</span>​。</p>
<h2 id="iv.-小结">IV. 小结</h2>
<p>至此，不管如何更换模数和进制，常见的单模哈希的所有情况均被上述算法卡掉。</p>
<p>所以<strong>一定要写双模！！！一定要写双模！！！一定要写双模！！！双模一定要改模数，不要只改进制！！！</strong></p>
]]></content>
      <categories>
        <category>一些毒瘤</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>NEUQ-ACM 预备队&amp;竞赛队寒假集训刷题小记</title>
    <url>/2024/01/21/%E3%80%90%E6%9D%82%E9%A2%98%E3%80%91NEUQ%20ACM%20%E9%A2%84%E5%A4%87%E9%98%9F%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD%E5%88%B7%E9%A2%98%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="brief">Brief</h2>
<p>NEUQ 寒假集训自主刷题记录，比较 trivival
会简记一下思路，比较困难会写解题报告或者题解记录一下。</p>
<span id="more"></span>
<p><span class="math inline">\(\textcolor{grey}{\bigstar}\)</span>
表示思维难度偏低、且各方面比较普通或比较套路的题（不考虑使用的算法）。</p>
<p><span class="math inline">\(\textcolor{green}{\bigstar}\)</span>
表示整体难度一般甚至偏低、但思考过程或结论可能具有启发性的小清新题目。</p>
<p><span class="math inline">\(\textcolor{brown}{\bigstar}\)</span>
表示思维难度中等的中档题。</p>
<p><span class="math inline">\(\textcolor{blue}{\bigstar}\)</span>
表示需要较高思维难度、思考过程或结论很具有启发性的题目。</p>
<p><span class="math inline">\(\textcolor{magenta}{\bigstar}\)</span>
表示需要一定知识基础和相关进阶算法的题。</p>
<p><span class="math inline">\(\textcolor{red}{\bigstar}\)</span>
表示思考了一段时间，但思考过程不完整，思路没有到位或只有部分正确，最终看题解才做出来的题。（最需要练习的题目）</p>
<h2 id="section"><strong>1.15</strong></h2>
<p>做题之余，整体复习了一下数论，稍微学习了一下二次剩余和离散对数。</p>
<p><strong>题目 <span class="math inline">\(01\)</span> ：</strong><a
href="https://atcoder.jp/contests/abc336/tasks/abc336_f">ABC336F -
Rotation Puzzle</a> <span
class="math inline">\(\textcolor{grey}{\bigstar}\textcolor{magenta}{\bigstar}\)</span>
<strong>[折半(搜索)思想]</strong></p>
<p><strong>思路：</strong>考虑进行四进制状压，<span
class="math inline">\(0,1,2,3\)</span>
分别代表左上、右上、左下和右下的旋转，但是有 <span
class="math inline">\(4^{20}\)</span>
种枚举状态。注意到最终状态是确定的，而且旋转操作可逆，那就可以采取折半搜索的方法，从起始状态枚举
<span class="math inline">\(10\)</span>
步，把状态存到哈希表中，再从末状态枚举 <span
class="math inline">\(10\)</span> 步，再从哈希表中查找，这样就只需要枚举
<span class="math inline">\(4^{10} = 2^{20}\)</span>
种状态了。假设上限步数为 <span class="math inline">\(n\)</span>
，则时间复杂度为 <span class="math inline">\(O(2^{n}nHW)\)</span> ，取
<span class="math inline">\(n = 20\)</span> 即可。</p>
<p><strong>题目 <span class="math inline">\(02\)</span> ：</strong> <a
href="https://atcoder.jp/contests/abc335/tasks/abc335_f">ABC335F - Hop
Sugoroku</a> <span
class="math inline">\(\textcolor{grey}{\bigstar}\textcolor{magenta}{\bigstar}\)</span>
<strong>[根号分治]</strong></p>
<p><strong>思路：</strong>设 <span class="math inline">\(f_i\)</span>
代表以 <span class="math inline">\(i\)</span> 为结尾且 <span
class="math inline">\(i\)</span> 被涂黑的方案数，不难发现 <span
class="math inline">\(f\)</span> 的转移可以根据 <span
class="math inline">\(a_i\)</span> 的大小进行根号分治。如果 <span
class="math inline">\(a_i \ge \sqrt{n}\)</span> ，直接暴力每次跳 <span
class="math inline">\(a_i\)</span> 进行转移，如果 <span
class="math inline">\(a_i &lt; \sqrt{n}\)</span> ，因为从 <span
class="math inline">\(i\)</span> 能跳到的所有位置 <span
class="math inline">\(p \bmod a_i\)</span> 一定等于 <span
class="math inline">\(i \bmod a_i\)</span>
，所以可以直接开一个二维数组记录模 <span
class="math inline">\(x\)</span> 等于 <span
class="math inline">\(y\)</span> 的位置上被加的贡献。时间复杂度为 <span
class="math inline">\(O(n\sqrt{n})\)</span> 。</p>
<h2 id="section-1"><strong>1.16</strong></h2>
<p>研究一个与离散对数有关的题，还没研究出来，然后上午 <span
class="math inline">\(11\)</span> 点的时候被叫去给预备队出题，然后花了
<span class="math inline">\(2.5\text{h}\)</span> 跟 ljc 和 zyb
搞了一套入门级别的题，然后下午的时候激情看榜（出了好多锅，甚至 <span
class="math inline">\(\text{B}\)</span>
题的数据还锅了，成为背锅人），最后一起写了<a
href="https://www.luogu.com.cn/blog/BrotherCall/neuq-acm-han-jia-ji-xun-huan-le-sai-1-guan-fang-ti-xie">题解</a>。</p>
<p>晚上继续研究那道题，最后终于搞明白了。近期准备写一个数论学习总结。</p>
<p><strong>题目 <span class="math inline">\(\text{03}\)</span>
：</strong> <a
href="https://atcoder.jp/contests/abc335/tasks/abc335_g">ABC335G -
Discrete Logarithm Problems</a> <span
class="math inline">\(\textcolor{blue}{\bigstar}\textcolor{magenta}{\bigstar}\textcolor{red}{\bigstar}\)</span>
<strong>[阶 | 原根 | 离散对数]</strong></p>
<p><strong>思路：</strong><a
href="https://tle-automat.top/2024/01/17/ABC335G/">【题解】ABC335G</a>。</p>
<p>搞完这个题之后，听 zyb 说了说<a
href="https://codeforces.com/contest/1921">昨晚 div.3</a>的 G
题，发现题有点怪，但做法很一般，那就口胡一个题解。</p>
<p><strong>题目 <span class="math inline">\(\text{04}\)</span>
：</strong><a
href="https://codeforces.com/contest/1921/problem/G">CF1921G -
Mischievous Shooter</a> <span
class="math inline">\(\textcolor{brown}{\bigstar}\)</span> <strong>[递推
| 二维前缀和]</strong></p>
<p><strong>思路：</strong>这题看着听唬人，实际上不太难想，只需要采取最普通的思路，只需要维护一下每行、每列、左斜线和右斜线的前缀和，四个方向都要跑一下类似于二维前缀和的递推，推出以每个点为端点，距离这个端点曼哈顿距离
<span class="math inline">\(\le k\)</span> 的方格的和即可，时间复杂度
<span
class="math inline">\(O(nm)\)</span>。但是边界啥的懒得想了，感觉稍微有些难写。</p>
<p>又听 zyb 说了昨晚 div.3 的 F
题，据说是根号分治，但想了半天没想出来其中一边怎么分，所以打算明天研究一下。</p>
<h2 id="section-2"><strong>1.17</strong></h2>
<p>上午写昨天的没搞完的 ABC335G
的题解，然后发现一个关键证明锅了，然后又花了一上午研究才彻底通透。</p>
<p>中午的时候博客出锅了，修了修 Blog，发现 hexo-renderer-kramed 和
hexo-renderer-marked 引擎渲染行间公式的时候
<code>$$</code>的转义有问题，离大谱。</p>
<p>下午听学长讲了几个构造题，挺有意思的，因为没有地方测也没有写，所以就不作为正式题目了。</p>
<p>一个是 lbf
学长自己想的跟俄罗斯方块有关的构造，给定一个初始局面，给一些面积为 <span
class="math inline">\(4\)</span>
的块，要求构造一些下落的方块之后回到初始局面，保证宽为偶数。想一想发现只需要开始时在最高的地方整一个反着的
<span class="math inline">\(\text{T}\)</span>
字，然后向两端铺㇅字，之后再随机应变向上填充，刚好能填充满 <span
class="math inline">\(4\)</span> 行。</p>
<p>另外一个是 <span class="math inline">\(\text{ec final}\)</span>
的一个题。就是给定两个 <span class="math inline">\(01\)</span> 串 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> ，保证两个串的首位都是 <span
class="math inline">\(1\)</span> ，每次可以把 <span
class="math inline">\(A\)</span>
的一个区间去掉前导零后看作三进制，然后转化成二进制再填回去，平均每位不超过
<span class="math inline">\(8\)</span> 步把 <span
class="math inline">\(A\)</span> 构造成 <span
class="math inline">\(B\)</span>
。因为可以去掉前导零，所以只需要花费很少的步数把 <span
class="math inline">\(A\)</span> 串变成全 <span
class="math inline">\(1\)</span> ，然后考虑怎么把全 <span
class="math inline">\(1\)</span> 串变成 <span
class="math inline">\(B\)</span>。因为 <span
class="math inline">\((11)_{3} = (100)_2\)</span> ，<span
class="math inline">\((10)_3 = (11)_2\)</span> ，所以假设 <span
class="math inline">\(B\)</span> 中有 <span
class="math inline">\(x\)</span> 个 <span
class="math inline">\(1\)</span> ，那只需要把 <span
class="math inline">\(A\)</span> 先变成连续的 <span
class="math inline">\(2x\)</span> 个 <span
class="math inline">\(1\)</span> ，这样每次修改连续的 <span
class="math inline">\(2\)</span> 个 <span
class="math inline">\(1\)</span> ，比如 <span class="math inline">\(11
\rightarrow 100 \rightarrow 110 \rightarrow 1000\)</span> ，即可实现把
<span class="math inline">\(11\)</span> 变成 <span
class="math inline">\(1\)</span> 加上任意多个 <span
class="math inline">\(0\)</span> ，步数很少，目测是足够的。</p>
<p>晚上研究了一下昨天说的哪个 div.3 F
题，发现自己被卡在了如何优美的定义数组上，遂记之。</p>
<p><strong>题目 <span class="math inline">\(\text{05}\)</span>
：</strong> <a
href="https://codeforces.com/contest/1921/problem/F">CF1921F - Sum of
Progression</a> <span
class="math inline">\(\textcolor{brown}{\bigstar}\textcolor{magenta}{\bigstar}\)</span>
<strong>[根号分治]</strong></p>
<p><strong>思路：</strong>我感觉这题的难度不在于想到根号分治，其实根号分治比较一眼，我被卡在了一个奇怪的地方。当
<span class="math inline">\(d \ge \sqrt{n}\)</span>
的时候显然直接暴力跳即可。当 <span class="math inline">\(d &lt;
\sqrt{n}\)</span> 的时候，可以预处理。具体的，枚举每一个步长 <span
class="math inline">\(d\)</span> ，再枚举起点 <span
class="math inline">\(st\)</span> ，然后挨着跳，预处理前缀和与 <span
class="math inline">\(\sum k \cdot a _{(k - 1)d + st}\)</span>
的前缀和，这样做的时间复杂度为 <span
class="math inline">\(O\left(\sum_{d = 1}^{\sqrt{n}} d \cdot
\displaystyle\frac{n}{d}\right) =
O(n\sqrt{n})\)</span>。但这样问题就出在预处理的数组要开 <span
class="math inline">\(3\)</span> 维，第一维存步长 <span
class="math inline">\(d\)</span>，第二维存起点 <span
class="math inline">\(st\)</span>，第三维存跳到哪儿了，因为数组没办法根据不同的
<span class="math inline">\(d\)</span> 给 <span
class="math inline">\(st\)</span>
开不同的长度，所以空间必须全都开满，所以空间复杂度就是 <span
class="math inline">\(O(\sqrt{n} \cdot\sqrt{n} \cdot n) =
O(n^{2})\)</span> 就炸了。但其实仔细想想没有必要开 <span
class="math inline">\(3\)</span> 维，因为只要确定当前跳到的位置 <span
class="math inline">\(p\)</span> ，和步长 <span
class="math inline">\(d\)</span> ，其他能跳到的位置可以通过 <span
class="math inline">\(p + kd\)</span>
计算得出，起点自然就确定了，所以只需要开二维数组预处理即可，剩下的就没有难度了。</p>
<h2 id="section-3">1.18</h2>
<p>今天上午跟出题组其他人一起准备了下午的预备队天梯赛 <span
class="math inline">\(1\)</span> 的题，并且写了题解。</p>
<p>简要在这里写一下<a
href="https://acjudge.com/d/northstarcup/p/151">我搬的那题</a>的题解：由勾股定理
<span class="math inline">\(a^{2} = c^{2} - b^{2} = (c + b)(c -
b)\)</span>，这启示我们去找 <span class="math inline">\(a^{2}\)</span>
的约数。将 <span class="math inline">\(a\)</span> 进行质因数分解有 <span
class="math inline">\(a = p_{1}^{k_1} p_{2}^{k_2} \cdots
p_{m}^{k_m}\)</span>，则 <span class="math inline">\(a^{2} =
p_{1}^{2k_1} p_{2}^{2k_2} \cdots
p_{m}^{2k_m}\)</span>，这一步的时间复杂度为 <span
class="math inline">\(O(\sqrt{a})\)</span>。考虑通过 <span
class="math inline">\(a^{2}\)</span> 的唯一分解，dfs
每一个质因数的指数，不重不漏地枚举 <span
class="math inline">\(a^{2}\)</span> 的约数。通过这个网站 <a
href="https://oeis.org/A066150">https://oeis.org/A066150</a> ，我们得知
<span class="math inline">\(10^{24}\)</span>
以内因数个数最多的数的因数个数是 <span
class="math inline">\(1290240\)</span>，所以时间复杂度可以保证，数学巨神
wrx 也给出了一个很严格的上界 <span
class="math inline">\(\operatorname{d}(n) &lt; n^{\frac{1.066}{\ln\ln
n}}\)</span>，通过这个也可以粗略计算 <span
class="math inline">\(10^{24}\)</span> 以内的数的因数个数最大是 <span
class="math inline">\(10^6\)</span>
级别。枚举约数的时候，顺便判断一下能否写成 <span
class="math inline">\(a^{2} = (c + b)(c - b)\)</span> 的形式即可，其中
<span class="math inline">\(a &lt; b &lt; c\)</span>。</p>
<p>下午写题，晚上打了一场 <a
href="https://codeforces.com/contest/1922">Edu div.2</a>，<span
class="math inline">\(6\)</span> 题过了 <span
class="math inline">\(5\)</span>
题，但罚时吃满了，预测上不了紫，希望不要 fst ，A 到 E 都挺简单，D
细节有点多，E 题好像还是原题。简记一下 D 和 E。</p>
<p><strong>题目 <span class="math inline">\(\text{06}\)</span>
：</strong><a
href="https://codeforces.com/contest/1922/problem/D">CF1922D - Berserk
Monsters</a> <span
class="math inline">\(\textcolor{grey}{\bigstar}\)</span> <strong>[模拟
| 链表]</strong></p>
<p><strong>思路：</strong>考虑每个怪最多只会死一次，维护一个链表，里面是当前活着的怪。维护两个
vector
分别代表这轮要寄的和下轮要寄的，每轮遍历一下这轮要寄的从链表中删除，然后更新一下下轮要寄的即可。</p>
<p><strong>题目 <span class="math inline">\(\text{07}\)</span>
：</strong><a
href="https://codeforces.com/contest/1922/problem/E">CF1922E -
Increasing Subsequences</a> <span
class="math inline">\(\textcolor{green}{\bigstar}\)</span> <strong>[构造
| 二进制]</strong></p>
<p><strong>思路：</strong>考虑将 <span class="math inline">\(x\)</span>
二进制分解，假设最高位为第 <span class="math inline">\(dig\)</span>
位，那么先构造一个长度为 <span class="math inline">\(dig\)</span>
的上升序列 <span class="math inline">\(h\)</span>，这样一开始的贡献是
<span class="math inline">\(2^{dig}\)</span> 。之后从高到低遍历 <span
class="math inline">\(x\)</span> 的其他位，如果第 <span
class="math inline">\(i\)</span> 位是 <span
class="math inline">\(1\)</span> ，那么在后面加一个介于 <span
class="math inline">\(h_i\)</span> 和 <span class="math inline">\(h_{i +
1}\)</span> 之间的数，这样产生的新的贡献就是 <span
class="math inline">\(2^{i}\)</span> ，这样最多需要 <span
class="math inline">\(60 + 60 = 120\)</span> 位就够了。</p>
<p><strong>题目 <span class="math inline">\(\text{08}\)</span>
：</strong><a
href="https://atcoder.jp/contests/abc334/tasks/abc334_f">ABC334F -
Christmas Present 2</a> <span
class="math inline">\(\textcolor{grey}{\bigstar}\)</span>
<strong>[动态规划 | 单调队列]</strong></p>
<p><strong>思路：</strong>考虑 <span
class="math inline">\(f_{i}\)</span> 代表送到第 <span
class="math inline">\(i\)</span> 的点然后回家的最小代价，因为一次最多拿
<span class="math inline">\(k\)</span> 个礼物，所以这个 dp
显然有类似滑动窗口的转移，跑一个前 <span
class="math inline">\(i\)</span>
个点的距离的前缀和预处理转移需要的代价，然后用单调队列优化即可。</p>
<p><strong>题目 <span class="math inline">\(\text{09}\)</span>
：</strong> <a
href="https://atcoder.jp/contests/abc334/tasks/abc334_g">ABC334G -
Christmas Color Grid 2</a> <span
class="math inline">\(\textcolor{grey}{\bigstar}\textcolor{magenta}{\bigstar}\)</span>
<strong>[点双连通分量 | 圆方树]</strong></p>
<p><strong>思路：</strong>考虑跑个点双，建出圆方树，然后每个统计每个圆点周围的方点个数，设为
<span class="math inline">\(x\)</span>
。那么删除这个圆点会导致连通块个数增加 <span class="math inline">\(x -
1\)</span> ，但是有一种特殊情况，就是只有一个圆点连接着 <span
class="math inline">\(0\)</span>
个方点，这样删除这个圆点会让连通块个数减 <span
class="math inline">\(1\)</span> 。用 tarjan
跑一下点双，剩下的期望随便算算就行了。</p>
<h2 id="section-4">1.19</h2>
<p>昨晚 CF 打完太兴奋了，然后打农和刷 B 站，凌晨 <span
class="math inline">\(3\)</span> 点才睡，第二天很晚才到 <span
class="math inline">\(\text{9028}\)</span>
训练，直接摆了一天，口胡了几个想补的题，完全不想写，明天再写吧（逃。</p>
<h2 id="section-5">1.20</h2>
<p>补了一下前天晚上 Edu 的 F 题，晚上打了场 ABC，结果 E 题最后 <span
class="math inline">\(n\)</span> 忘记加 <span
class="math inline">\(1\)</span>，一直找不到什么错，心态卡崩了，浪费了很多时间。而且长时间疏于数据结构，导致可持久化线段树已经忘得差不多了，粘板子改的也非常慢，最后
G 也没写完/kk/kk/kk。</p>
<p><strong>题目 <span class="math inline">\(10\)</span> ：</strong><a
href="https://codeforces.com/contest/1922/problem/F">CF1922F - Replace
on Segment</a> <span
class="math inline">\(\textcolor{brown}{\bigstar}\textcolor{red}{\bigstar}\)</span>
<strong>[区间dp]</strong></p>
<p><strong>思路：</strong> 考虑区间 dp。设 <span
class="math inline">\(f_{i, j, x}\)</span> 表示把区间 <span
class="math inline">\([i, j]\)</span> 上的数全部变成 <span
class="math inline">\(x\)</span>
的最小代价。考虑转移，发现分为两种情况。第一种是将区间分为至少两端分别变成
<span class="math inline">\(x\)</span> ，这种情况可以通过 <span
class="math inline">\(f_{i, j, x} = \min\limits_{k = i}^{j -
1}\{f_{i,k,x} + f_{k+1, j, x}\}\)</span>
进行转移。第二种是先操作一些区间，最后将 <span class="math inline">\([i,
j]\)</span> 整体一次变成 <span class="math inline">\(x\)</span>
，但这种情况要求先通过前面的操作将区间 <span class="math inline">\([i,
j]\)</span> 的所有数变成非 <span class="math inline">\(x\)</span>
的数，思考一下可以发现，去掉 <span class="math inline">\([i, j]\)</span>
上等于 <span class="math inline">\(x\)</span>
的数的代价最小的方案，一定是一段一段地用数字覆盖。考虑令 <span
class="math inline">\(g_{i, j, x}\)</span> 表示将区间 <span
class="math inline">\([i, j]\)</span> 整体变成一个数 <span
class="math inline">\(y\)</span>，使得 <span class="math inline">\(y
\neq x\)</span> 的最小代价，这个可以通过 <span
class="math inline">\(f\)</span> 轻松推出。考虑取出区间 <span
class="math inline">\([i, j]\)</span> 上所有 <span
class="math inline">\(a_p = x\)</span> 的位置，令 <span
class="math inline">\(h_r\)</span> 表示前 <span
class="math inline">\(r\)</span> 个位置均被覆盖成非 <span
class="math inline">\(x\)</span> 的数的最小代价，有转移 <span
class="math inline">\(h_r = \min\limits_{l = 1} ^{r} \{h_{l - 1} +
g_{pos_{l},pos_{r},x}\} , f_{i, j, x} \leftarrow
h_{\operatorname{cnt}(x)} + 1\)</span>，<span
class="math inline">\(\operatorname{cnt}(x)\)</span> 表示区间 <span
class="math inline">\([i, j]\)</span> 上 <span
class="math inline">\(x\)</span>
的个数。还剩最后一个问题，这样的总复杂度转移看似是 <span
class="math inline">\(O(Tn^{5})\)</span> 的，因为除去枚举区间的 <span
class="math inline">\(O(n^{2})\)</span>，还有 <span
class="math inline">\(O(n^{3 })\)</span>
的转移。其实分析一下每一个位置对于复杂度的贡献发现 <span
class="math inline">\(O\left(\sum\limits_{i = 1}^{n}
[\operatorname{cnt}(i)]^{2}\right) =
O(n^{2})\)</span>，所以枚举完区间之后的转移实际上是 <span
class="math inline">\(O(n^{2})\)</span>，所以总复杂度是 <span
class="math inline">\(O(Tn^{4})\)</span>，卡满是 <span
class="math inline">\(5 \times 10^{8}\)</span>，但循环完全跑不满，而且有
<span class="math inline">\(3\text{s}\)</span>
的时限，可以通过，实际上最慢的只跑了 <span
class="math inline">\(600\text{ms}\)</span> 左右。（这里 <span
class="math inline">\(n\)</span> 和 <span
class="math inline">\(X\)</span> 同阶，不做区分）</p>
<p><strong>题目 <span class="math inline">\(11\)</span> ：</strong><a
href="https://atcoder.jp/contests/abc337/tasks/abc337_g">ABC337G - Tree
Inversion</a> <span
class="math inline">\(\textcolor{brown}{\bigstar}\textcolor{magenta}{\bigstar}\)</span>
<strong>[树形dp | 换根dp | 主席树]</strong></p>
<p><strong>思路：</strong>考虑先 dfs 一遍，开个树状数组，把结点 <span
class="math inline">\(1\)</span>
的答案算出来，然后考虑换根时贡献的改变。考虑从 <span
class="math inline">\(fa\)</span> 换到 <span
class="math inline">\(u\)</span> ，假设 <span
class="math inline">\(v\)</span> 在 <span
class="math inline">\(u\)</span> 的子树内部，那么所有 <span
class="math inline">\(fa\)</span> 到 <span
class="math inline">\(v\)</span> 的路径上 <span class="math inline">\(w
= fa\)</span> 的贡献都要减掉，即减去 <span
class="math inline">\(u\)</span> 的子树内结点编号小于 <span
class="math inline">\(fa\)</span> 的结点的个数。同理，贡献还要加上 <span
class="math inline">\(u\)</span> 的子树外结点编号小于 <span
class="math inline">\(u\)</span> 的结点的个数。直接预处理出树的 dfs
序，每次换根相当于查询一个区间有多少个数小于 <span
class="math inline">\(k\)</span>，因为没有修改所以是静态的查询，直接用主席树处理即可。（以后有时间一定把数据结构封装一个模板）</p>
<h2 id="section-6">1.21</h2>
<p>昨天晚上因为 E 题忘记写 <span class="math inline">\(n + 1\)</span>
卡了 <span class="math inline">\(40\text{min}\)</span>
心态崩了，打农打到特别晚，因此第二天起的特别晚，摆了一天，F
题处于一种一知半解的状态，然后打了晚上的 ARC。C
题是一个很天才的套路，但我不知道，看题解知道了这个套路，遂记之。</p>
<p><strong>题目 <span class="math inline">\(12\)</span> ：</strong><a
href="https://atcoder.jp/contests/arc170/tasks/arc170_c">ARC170C -Prefix
Mex Sequence</a> <span
class="math inline">\(\textcolor{blue}{\bigstar}\textcolor{red}{\bigstar}\)</span>
<strong>[dp]</strong></p>
<p><strong>思路：</strong>如果这题思路一直限制在 <span
class="math inline">\(\operatorname{mex}\)</span>
上，那么可能很难回到正轨了。首先注意到前 <span class="math inline">\(i -
1\)</span> 数的 <span class="math inline">\(\text{mex}\)</span> 的最大为
<span class="math inline">\(i\)</span>，所以直接枚举 <span
class="math inline">\(\text{mex}\)</span> 是 <span
class="math inline">\(O(\min(n, m))\)</span> 级别的，那假设我们设 <span
class="math inline">\(f_{i, j}\)</span> 代表前 <span
class="math inline">\(i\)</span> 个数的 <span
class="math inline">\(\text{mex}\)</span> 为 <span
class="math inline">\(j\)</span> 且符合题目条件的方案数，发现 <span
class="math inline">\(s_{i + 1} = 1\)</span> 时下一个状态的 <span
class="math inline">\(\text{mex}\)</span>
我们无法得知，不能进行转移，然后我就卡在这里了。注意到不管 <span
class="math inline">\(\text{mex}\)</span> 是什么数， 假设 <span
class="math inline">\(s_{i + 1} = 1\)</span>，那么 <span
class="math inline">\(a_{i + 1}\)</span> 一定在 <span
class="math inline">\(a_1 , a_{2} , \cdots, a_{i}\)</span>
中没出现过。那我们不妨设 <span class="math inline">\(f_{i, j}\)</span>
代表前 <span class="math inline">\(i\)</span> 个位置在满足题意的条件下有
<span class="math inline">\(j\)</span>
个不同的数的方案数，这样可以巧妙避免 <span
class="math inline">\(\text{mex}\)</span>
被记录到状态中导致无法转移的问题，更具体地说 <span
class="math inline">\(\text{mex}\)</span> 只会对这个 dp
的转移过程进行限制。若 <span class="math inline">\(s_{i + 1} =
1\)</span>，相当于<strong>能且只能</strong>填入 <span
class="math inline">\(\text{mex}\{a_1, a_2, \cdots,
a_{n}\}\)</span>，所以 <span class="math inline">\(j\)</span> 一定会加
<span class="math inline">\(1\)</span>，即进行转移 <span
class="math inline">\(f_{i, j} \rightarrow f_{i + 1, j + 1}\)</span>
；若 <span class="math inline">\(s_{i + 1} =
0\)</span>，如果填入之前已经填入的数，即进行转移 <span
class="math inline">\(j \times f_{i, j} \rightarrow f_{i + 1,
j}\)</span>，如果填入之前不存在的数，那么有 <span
class="math inline">\((m + 1) - j - 1\)</span> 种填数方式，减 <span
class="math inline">\(1\)</span> 是因为 <span
class="math inline">\(\text{mex}\{a_1, a_2, \cdots, a_{n}\}\)</span>
不能填，即进行转移 <span class="math inline">\((m - j) \times f_{i, j}
\rightarrow f_{i + 1, j + 1}\)</span>。最终答案 <span
class="math inline">\(\displaystyle{ans = \sum\limits_{i = 1}^{\min(n, m
+ 1)} f_{n, i}}\)</span>，时间复杂度为 <span
class="math inline">\(O(n^{2})\)</span>，可以通过。</p>
<h2 id="section-7">1.22</h2>
<p>vp 了 <a
href="https://codeforces.com/contest/1777/problem/D">Codeforces Round
845 Div.2</a>，赛时 <span class="math inline">\(4\)</span>
题，后面的题还没补，但是觉得 D 挺有意思的，遂记录一下。</p>
<p><strong>题目 <span class="math inline">\(13\)</span> ：</strong><a
href="https://codeforces.com/contest/1777/problem/D">CF1777D - Score of
a Tree</a> <span
class="math inline">\(\textcolor{brown}{\bigstar}\)</span>
<strong>[贡献的拆分 | 树形结构]</strong></p>
<p><strong>思路：</strong>考虑把贡献拆开，计算每个结点 <span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(t\)</span> 时刻对答案的贡献。注意到结点 <span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(t\)</span> 时刻的值只会被 <span
class="math inline">\(x\)</span> 向下 <span
class="math inline">\(t\)</span> 层的子节点影响，假设 <span
class="math inline">\(x\)</span> 向下 <span
class="math inline">\(t\)</span> 层的子节点有 <span
class="math inline">\(cnt\)</span> 个，那么这 <span
class="math inline">\(cnt\)</span> 个结点的权值在 <span
class="math inline">\(t = 0\)</span> 时有奇数个 <span
class="math inline">\(1\)</span> 才能使得 <span
class="math inline">\(x\)</span> 结点在 <span
class="math inline">\(t\)</span> 时刻的权值为 <span
class="math inline">\(1\)</span>，所以初始时这 <span
class="math inline">\(cnt\)</span> 个结点的方案数为 <span
class="math inline">\(\binom{cnt}{1} + \binom{cnt}{3} + \binom{cnt}{5} +
\cdots = 2^{cnt - 1}\)</span>，因为其他结点初始的值对 <span
class="math inline">\(x\)</span> 在 <span
class="math inline">\(t\)</span> 时刻的权值没有影响，所以有 <span
class="math inline">\(2^{n - cnt}\)</span> 种方案。所以如果 <span
class="math inline">\(x\)</span> 向下 <span
class="math inline">\(t\)</span>
层具有子节点，不管具有多少个子节点，对答案的贡献都是 <span
class="math inline">\(2^{cnt - 1} \times 2^{n - cnt} = 2^{n -
1}\)</span>。所以只需要 dfs
求出每个节点向下最深的结点的深度，然后计算贡献即可。</p>
<h2 id="section-8">1.23</h2>
<p>学长给预备队出了一套模拟赛，听到学长讲了一个有意思的东西，就是三个整点没法组成一个等边三角形。因为边长
<span class="math inline">\(a\)</span> 的平方一定是整数，而 <span
class="math inline">\(\displaystyle{S =
\frac{\sqrt{3}}{4}a^{2}}\)</span>
一定是无理数，但是根据皮克定理，整点多边形的面积一定是有理数，所以一定不存在三个整点构成的等边三角形。</p>
<p>补了一下上场 ARC 的 D 题，一个很有意思的博弈论思维题。</p>
<p><strong>题目 <span class="math inline">\(\text{14}\)</span>
：</strong><a
href="https://atcoder.jp/contests/arc170/tasks/arc170_d">ARC170D -
Triangle Card Game</a> <span
class="math inline">\(\textcolor{blue}{\bigstar}\)</span>
<strong>[博弈论 | 思维题]</strong></p>
<p><strong>思路：</strong>考虑组成三角形的三边满足的限制，发现写成三个不等式非常繁琐，但可以简化一下写法。假设
<span class="math inline">\(a \ge b &gt; 0\)</span>，则 <span
class="math inline">\(a, b, c\)</span> 构成三角形的充要条件是 <span
class="math inline">\(a - b &lt; c &lt; a + b\)</span>。发现只要确定了
<span class="math inline">\(a, b\)</span>，那么 <span
class="math inline">\(c\)</span> 必须落在区间 <span
class="math inline">\((a - b, a + b)\)</span> 上。假设 Alice 选了 <span
class="math inline">\(a_i\)</span>，Bob 选了 <span
class="math inline">\(b_j\)</span>，那么有两种情况：</p>
<ol type="1">
<li><p><span class="math inline">\(a_i \ge b_j\)</span></p>
<p>此时 Alice 下一次必须选区间 <span class="math inline">\((a_i - b_j,
a_i + b_j)\)</span> 上的数才能赢，所以 Bob 肯定希望 Alice
能选的可行区间半径尽量小，所以 Bob 一定会选 <span
class="math inline">\(b_{1}\)</span>（假设数组 <span
class="math inline">\(a, b\)</span>
都从小到大排过序了），这样我们只需要看有没有 <span
class="math inline">\(a_k\)</span> 满足 <span class="math inline">\(k
\neq i\)</span> 且 <span class="math inline">\(a_{k} \in (a_i - b_1, a_i
+ b_1)\)</span> 即可，实际上就是判断距离 <span
class="math inline">\(a_i\)</span> 最近的数的距离是否小于 <span
class="math inline">\(b_1\)</span>。</p></li>
<li><p><span class="math inline">\(a_i &lt; b_j\)</span></p>
<p>此时 Alice 下一次必须选区间 <span class="math inline">\((b_j - a_i,
b_j + a_i)\)</span> 上的数才能赢。此时 <span
class="math inline">\(a_i\)</span> 为可选区间的半径，半径越大 Alice
肯定越容易赢。再结合 <span class="math inline">\(1\)</span>
中的分析，可以得出 Alice 的最优策略为：在保证 Bob 选择 <span
class="math inline">\(b_1\)</span> 时自己不会输的条件下，选择最大的
<span class="math inline">\(a_i\)</span>。</p></li>
</ol>
<p>由上，我们可以 <span class="math inline">\(O(n\log n)\)</span>
地解决此题，其中的 <span class="math inline">\(\log\)</span>
来自排序。</p>
<h2 id="section-9">1.24</h2>
<p>听 czy
学长讲了个奥数题思维题，准备出到预备队的比赛里，觉得很有意思，准备专门开一篇博客记录这种题和类似的
idea。</p>
<h2 id="section-10">1.25</h2>
<p>又 vp 了一场 <a href="https://codeforces.com/contest/1905">CF
div.2</a>，赛后补了 D 和 E 写一下简要题解，D
是一个均摊时间复杂度的妙妙题。</p>
<p><strong>题目 <span class="math inline">\(\text{15}\)</span>
：</strong><a
href="https://codeforces.com/contest/1905/problem/D">CF1905D - Cyclic
MEX</a> <span class="math inline">\(\textcolor{brown}{\bigstar}\)</span>
<strong>[时间复杂度均摊]</strong></p>
<p><strong>思路：</strong>先把 <span class="math inline">\(0\)</span>
移到最右边，考虑每次循环左移时每个位置 <span
class="math inline">\(\text{mex}\)</span> 的变化。容易得到 <span
class="math inline">\(0\)</span> 左边的所有位置的 <span
class="math inline">\(\text{mex}\)</span> 全都是 <span
class="math inline">\(0\)</span>，假设循环左移时最左边移到最右边的数是
<span class="math inline">\(x\)</span>，那么 <span
class="math inline">\(0\)</span> 右边所有位置的 <span
class="math inline">\(\text{mex}\)</span> 如果比 <span
class="math inline">\(x\)</span> 小则不会受到影响，如果比 <span
class="math inline">\(x\)</span> 大则会变成 <span
class="math inline">\(x\)</span>，最后一个位置的 <span
class="math inline">\(\text{mex}\)</span> 依然是 <span
class="math inline">\(n\)</span>。所以相当于维护一个单调非降的序列的和，每次操作把大于
<span class="math inline">\(x\)</span> 的后缀变成 <span
class="math inline">\(x\)</span>，并且在末尾添加上一个 <span
class="math inline">\(n\)</span>。我们可以把连续且相同的一些位置缩成一个块，这样每次暴力修改是
<span class="math inline">\(O(cnt)\)</span> 的，<span
class="math inline">\(cnt\)</span> 是大于 <span
class="math inline">\(x\)</span>
的块数。因为每个块只会被删除一次，每次修改最多添加 <span
class="math inline">\(2\)</span> 个新的块，所以总块数 <span
class="math inline">\(O(\sum cnt) = O(n)\)</span>，均摊每次操作是 <span
class="math inline">\(O(1)\)</span>，总时间复杂度是 <span
class="math inline">\(O(n)\)</span> 的。</p>
<p><strong>题目 <span class="math inline">\(\text{16}\)</span>
：</strong><a
href="https://codeforces.com/contest/1905/problem/E">CF1905E - One-X</a>
<span class="math inline">\(\textcolor{blue}{\bigstar}\)</span>
<strong>[贡献的拆分 | dp]</strong></p>
<p><strong>思路：</strong>注意到线段树每层最多只有<strong>两种</strong>不同的线段长度，而且根节点线段长度相同的线段树的结构是相同的。假设当前根节点线段长度是
<span class="math inline">\(len\)</span>，编号为 <span
class="math inline">\(id\)</span>，那么当前结点产生的贡献是 <span
class="math inline">\(id \cdot (2^{\lfloor\frac{len + 1}{2}\rfloor} -
1)\cdot (2^{\lfloor\frac{len}{2}\rfloor} -
1)\)</span>。所以直接递推出每一层的两种线段的个数与编号之和，直接计算贡献即可。加上快速幂，总时间复杂度是
<span class="math inline">\(O(\log^{2}(n))\)</span> 的。</p>
<h2 id="section-11">1.26</h2>
<p>晚上打了一场 <a href="https://codeforces.com/contest/1925">CF Round
921 div.2</a>，赛时 <span class="math inline">\(59\text{min}\)</span>
做了 <span class="math inline">\(4\)</span>
题终于上紫名了，总算是实现了高中退役前的梦想。</p>
<p>晚上随便打了点牛客周赛的题，就不写了。</p>
<p><strong>题目 <span class="math inline">\(\text{17}\)</span>
：</strong><a
href="https://codeforces.com/contest/1925/problem/E">CF1925E - Space
Harbour</a> <span
class="math inline">\(\textcolor{brown}{\bigstar}\textcolor{magenta}{\bigstar}\)</span>
<strong>[线段树]</strong></p>
<p><strong>思路：</strong>考虑在 <span
class="math inline">\(pos\)</span>
位置插入一个新的港口对其他位置的贡献。对于 <span
class="math inline">\(pos\)</span> 左边，插入前的总贡献是 <span
class="math inline">\(v_{pre} \times (nxt - x)\)</span>，插入后总贡献是
<span class="math inline">\(v_{pre} \times(pos - x)\)</span>，<span
class="math inline">\(\Delta = v_{pre}\times(pos - nxt)\)</span>。对于
<span class="math inline">\(pos\)</span> 右边，插入前的总贡献是 <span
class="math inline">\(v_{pre} \times (nxt - x)\)</span>，插入后的总贡献
<span class="math inline">\(v_{pos} \times (nxt - x)\)</span>，<span
class="math inline">\(\Delta = (v_{pos} - v_{pre}) \times(nxt - x) =
-(v_{pos} - v_{pre})x +(v_{pos} - v_{pre})nxt\)</span>。所以每个位置
<span class="math inline">\(x\)</span> 的贡献是 <span
class="math inline">\(kx + b\)</span> 的形式，操作只有对 <span
class="math inline">\(k\)</span> 和 <span
class="math inline">\(b\)</span> 的区间加，对 <span
class="math inline">\(kx + b\)</span> 的区间查询，可以用线段树维护。</p>
<h2 id="section-12">1.27</h2>
<p>补一下昨天的 CF div.2 的 F 题。</p>
<p><strong>题目 <span class="math inline">\(\text{18}\)</span>
：</strong> <a
href="https://codeforces.com/contest/1925/problem/F">CF1925F - Fractal
Origami</a> <span
class="math inline">\(\textcolor{blue}{\bigstar}\)</span>
<strong>[几何]</strong></p>
<p><strong>思路：</strong><a
href="https://tle-automat.top/2024/02/02/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91CF1925F/#more">【题解】CF1925F</a></p>
<h2 id="section-13">1.28 ~ 1.30</h2>
<p>摸鱼 + 摆烂 + 给最后一场比赛搞题。</p>
<h2 id="section-14">1.31</h2>
<p>收拾东西，回家喽！</p>
]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>QwQ</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC352G - Socks 3</title>
    <url>/2024/05/07/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91ABC352G/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://atcoder.jp/contests/abc352/tasks/abc352_g">https://atcoder.jp/contests/abc352/tasks/abc352_g</a></p>
<h2 id="题目大意">题目大意</h2>
<p>总共有 <span class="math inline">\(N\)</span> 种不同颜色的袜子，第
<span class="math inline">\(i\)</span> 种颜色的袜子有 <span
class="math inline">\(A_i\)</span>
只。现在高桥要按照以下规则决定早上穿哪一双袜子：</p>
<ul>
<li><p>从当前剩余的袜子中等概率随机且不放回地抽取一只袜子。</p></li>
<li><p>若抽出的袜子颜色与之前某次抽出的袜子颜色相同，则停止操作并穿这种颜色的袜子；</p>
<p>若抽出的袜子颜色与之前每一次抽出的颜色均不同，则进行下一次抽取操作。</p></li>
</ul>
<p>求高桥抽取袜子次数的期望值，对 <span
class="math inline">\(998244353\)</span> 取模。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(1 \le N \le 3\times 10^{5}\)</span></li>
<li><span class="math inline">\(2 \le A_i \le 3000\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p>设 <span class="math inline">\(f_k\)</span> 代表抽了 <span
class="math inline">\(k\)</span>
次袜子之后还没有凑出来一对相同颜色袜子的概率，那 <span
class="math inline">\(f_k - f_{k + 1}\)</span> 就是第 <span
class="math inline">\(k + 1\)</span>
次抽袜子凑出来了一对相同颜色袜子的概率，设 <span
class="math inline">\(tot = \sum A_i\)</span>，那么期望次数就是 <span
class="math inline">\(\displaystyle{\sum_{k = 0}^{n}} (f_k - f_{k + 1})
\times (k + 1)\)</span>。接下来考虑怎么求出 <span
class="math inline">\(f\)</span>。</p>
因为每种袜子抽到不能超过 <span class="math inline">\(1\)</span>
次，考虑枚举抽到了 <span class="math inline">\(p_1, p_2, \cdots,
p_k\)</span> 这些种类的袜子，那么有 $$
<span class="math display">\[\begin{aligned}

f_k &amp;= \sum\limits_{\{p_1, p_2, \cdots, p_k\} \sub \{1, 2, \cdots,
n\}} k! \cdot \frac{A_{p_1}}{tot} \cdot \frac{A_{p_2}}{tot - 1} \cdots
\frac{A_{p_k}}{tot - (k - 1)} \\

&amp;= \frac{k!(tot - k)!}{tot!} \sum\limits_{\{p_1, p_2, \cdots, p_k\}
\sub \{1, 2, \cdots, n\}} A_{p_1} A_{p_2}\cdots A_{p_k}

\end{aligned}\]</span>
<p>$$ 令 <span class="math inline">\(g_k =
\displaystyle\sum\limits_{\{p_1, p_2, \cdots, p_k\} \sub \{1, 2, \cdots,
n\}} A_{p_1} A_{p_2}\cdots A_{p_k}\)</span>，注意到 <span
class="math inline">\(g_k\)</span> 的含义就是从 <span
class="math inline">\(n\)</span> 个里面选 <span
class="math inline">\(k\)</span> 个所有方案的乘积之和。</p>
<p>可以把序列分为左右两部分，两部分的 <span
class="math inline">\(g\)</span> 分别求出来，做一遍卷积就得到合起来的
<span class="math inline">\(g\)</span> 了，使用分治即可，时间复杂度
<span class="math inline">\(O(n\log^{2}n)\)</span>。</p>
<h2 id="参考代码">参考代码</h2>
<p><a
href="https://atcoder.jp/contests/abc352/submissions/53158065">https://atcoder.jp/contests/abc352/submissions/53158065</a></p>
]]></content>
      <categories>
        <category>AtCoder解题报告</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>概率与期望</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】AGC066A - Adjacent Difference</title>
    <url>/2024/04/03/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91AGC066A/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://atcoder.jp/contests/agc066/tasks/agc066_a">https://atcoder.jp/contests/agc066/tasks/agc066_a</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定一个 <span class="math inline">\(N \times N\)</span> 的方阵 <span
class="math inline">\(A_{i, j}\)</span> 和一个正整数 <span
class="math inline">\(d\)</span>。每次可以花费 <span
class="math inline">\(x\)</span> 的代价将矩阵的某一个位置加上 <span
class="math inline">\(x\)</span> 或减去 <span
class="math inline">\(x\)</span>。请构造一种方案使得方阵中所有相邻位置的差的绝对值大于等于
<span class="math inline">\(d\)</span>，且代价之和小于等于 <span
class="math inline">\(\frac{1}{2}N^{2}d\)</span>。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(2\le N \le 500\)</span></li>
<li><span class="math inline">\(1\le d \le 1000\)</span></li>
<li><span class="math inline">\(-1000 \le A_{i, j} \le
1000\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p>先说结论：</p>
<ol type="1">
<li>将方阵黑白染色，然后将<strong>黑色</strong>的位置变为 <span
class="math inline">\(\bmod 2d = 0\)</span>
的最近的数，将<strong>白色</strong>的位置变为 <span
class="math inline">\(\bmod 2d = d\)</span> 的最近的数，假设代价此为
<span class="math inline">\(c_0\)</span>​。</li>
<li>将方阵黑白染色，然后将<strong>白色</strong>的位置变为 <span
class="math inline">\(\bmod 2d = 0\)</span>
的最近的数，将<strong>黑色</strong>的位置变为 <span
class="math inline">\(\bmod 2d = d\)</span> 的最近的数，假设代价此为
<span class="math inline">\(c_1\)</span>。</li>
</ol>
<p>则上述两种情况中必有一种满足条件。</p>
<p>证明：</p>
<p>由于上述构造中黑白相邻位置的差的绝对值至少为 <span
class="math inline">\(d\)</span>，所以满足第一个条件。</p>
<p>考虑第二个条件。假设把一个位置上的数变为 <span
class="math inline">\(\bmod 2d = 0\)</span> 的最近数的代价为 <span
class="math inline">\(x\)</span>，变为 <span class="math inline">\(\bmod
2d = d\)</span> 的最近的数的代价为 <span
class="math inline">\(y\)</span>，那么一定有 <span
class="math inline">\(x + y = d\)</span>。这就意味着 <span
class="math inline">\(c_0 + c_1 = N ^ {2} d\)</span>，则 <span
class="math inline">\(c_0\)</span> 和 <span
class="math inline">\(c_1\)</span> 中必有一个小于等于 <span
class="math inline">\(\frac{1}{2}N^{2}d\)</span>。</p>
<h2 id="参考代码">参考代码</h2>
<p><a
href="https://atcoder.jp/contests/agc066/submissions/51989697">https://atcoder.jp/contests/agc066/submissions/51989697</a></p>
]]></content>
      <categories>
        <category>AtCoder解题报告</category>
      </categories>
      <tags>
        <tag>人类の智慧</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】CF1942E - Farm Game</title>
    <url>/2024/04/01/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91CF1942E/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://codeforces.com/contest/1942/problem/E">https://codeforces.com/contest/1942/problem/E</a></p>
<h2 id="题目大意">题目大意</h2>
<p>小 N 和小 J 各有 <span class="math inline">\(n\)</span> 头奶牛，小 N
的奶牛位置为 <span class="math inline">\(a_1, a_2, \cdots,
a_n\)</span>，小 J 的奶牛位置为 <span class="math inline">\(b_1, b_2,
\cdots, b_n\)</span>。其中小 N 和小 J 的奶牛交替出现，且位置在 <span
class="math inline">\(1\)</span> 与 <span
class="math inline">\(l\)</span> 之间，即满足 <span
class="math inline">\(0 &lt; a_1 &lt; b_1 &lt; a_2 &lt; b_2 &lt; \cdots
&lt; a_n &lt; b_n &lt; l + 1\)</span> 或 <span class="math inline">\(0
&lt; b_1 &lt; a_1 &lt; b_2 &lt; a_2 &lt; \cdots &lt; b_n &lt; a_n &lt; l
+ 1\)</span>。</p>
<p>现在小 J 和小 N 轮流进行以下操作，小 J 先手：</p>
<ul>
<li>当前操作的人任意选中自己的 <span class="math inline">\(k(1 \le k \le
n)\)</span>
头奶牛，并且让这些奶牛一起向左或向右移动<strong>一格</strong>。移动后，位置不能与另外一个人的奶牛重合，也不能超出边界（即位置不能小于
<span class="math inline">\(1\)</span> 也不能大于 <span
class="math inline">\(n\)</span>）。</li>
<li>若无法进行上述操作，当前操作的人判负。</li>
</ul>
<p>问有多少种合法的序列组合 <span class="math inline">\((a,
b)\)</span>，使得小 J 必胜（两人均足够聪明）。</p>
<h2 id="数据范围">数据范围</h2>
<p>多组测试数据，保证</p>
<ul>
<li><span class="math inline">\(2 \le l \le 10^6 , \sum l \le
10^{6}\)</span></li>
<li><span class="math inline">\(1 \le n \le
\left\lfloor\frac{l}{2}\right\rfloor\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p>十分有意思的小清新博弈和组合数学题。</p>
<h3 id="step-1">Step 1​</h3>
<p>这题要求我们对先手必胜态进行计数，要计数我们必须要先搞清楚先手必胜态长什么样子。</p>
<p>先考虑比较简单的情况，如果 <span class="math inline">\(n =
1\)</span>，此时发现如果小 J 的奶牛与小 N 的奶牛贴贴，那么小 J
必败；否则，小 J 和小 N 要尽量避免自己的奶牛被对方贴贴。</p>
<p>我们又发现，操作的人把自己的奶牛向使相对距离变远的方向移动是没有意义的，因为下一个操作的人模仿相同的动作总能把相对距离变回原来的状态。</p>
<p>所以 <span class="math inline">\(n = 1\)</span> 时小 J
是否必胜只与两头奶牛的相对距离的奇偶性有关。</p>
<h3 id="step-2">Step 2</h3>
<p>我们 <span class="math inline">\(n\)</span>
为任意正整数时上述结论仍然成立，即</p>
<ul>
<li>小 J 和小 N 的奶牛两两贴贴时先手必败。</li>
<li>操作的人把自己的奶牛向使相对距离变远的方向移动是没有意义的。</li>
</ul>
<p>所以两两配对的奶牛之间的距离只会一直缩小至 <span
class="math inline">\(0\)</span>。</p>
<p>问题可以转化为给定 <span class="math inline">\(n\)</span>
堆石子，每次选取任意个（不能不选）剩余石子个数大于 <span
class="math inline">\(0\)</span> 的堆，从这些堆的每一堆中都取走 <span
class="math inline">\(1\)</span> 个石子，问先手是否必胜。</p>
<h3 id="step-3">Step 3</h3>
<p>分析上一步转化的问题，发现<strong>先手必败</strong>的充要条件是所有堆的石子数均为偶数。</p>
<p><strong>证明：</strong>如果石子堆中有奇数的堆，先手可以通过一次操作使得所有的堆中石子数均为偶数；否则，先手操作后至少会有一个奇数的堆。又因为最终不能操作的状态为全
<span
class="math inline">\(0\)</span>，都是偶数。所以如果有奇数的堆，先手每次操作后都能控制所有堆中的石子都是偶数，以此把后手逼迫到全
<span class="math inline">\(0\)</span>。</p>
<h3 id="step-4">Step 4</h3>
<p>经过上述分析，问题变为统计从长为 <span
class="math inline">\(l\)</span>
的段中截取出若干个不相交的长度不全为偶数的子段的方案数。</p>
<p>不妨先统计总方案，再减去长度全为偶数的方案。</p>
<p>每一部分的方案使用乘法原理和隔板法计算即可。</p>
<p>最后答案别忘记乘 <span class="math inline">\(2\)</span>，因为可以把小
J 的奶牛放在前面，也可以把小 N 的奶牛放在前面。</p>
<h2 id="参考代码">参考代码</h2>
<p><a
href="https://codeforces.com/contest/1942/submission/254441026">https://codeforces.com/contest/1942/submission/254441026</a></p>
]]></content>
      <categories>
        <category>Codeforces解题报告</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】CF1929E - Sasha and the Happy Tree Cutting</title>
    <url>/2024/02/18/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91CF1929E/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://codeforces.com/contest/1929/problem/E">https://codeforces.com/contest/1929/problem/E</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定一颗 <span class="math inline">\(n\)</span> 个结点的树，给定
<span class="math inline">\(k\)</span> 条树上的路径 <span
class="math inline">\(a_i, b_i\)</span>。现在要对树上的一些边染色，使得
<span class="math inline">\(k\)</span>
条路径中的每一条路径上都至少有一条边被染色，问最少染多少条边。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(2\le n \le 10^{5}\)</span></li>
<li><span class="math inline">\(1 \le k \le 20\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p>考虑统计每一条边被那些路径覆盖，假设覆盖第 <span
class="math inline">\(i\)</span> 边的路径集合为 <span
class="math inline">\(S_i\)</span>，那就是要找到一个长度最短的序列 <span
class="math inline">\(p_1, p_2, \cdots, p_m\)</span> 使得 <span
class="math inline">\(S_{P_1} \cup S_{p_2} \cup \cdots \cup S_{p_m} =
\{1, 2, \cdots, k\}\)</span>。</p>
<p>我们联想到了状压 dp，但发现直接 dp 复杂度是 <span
class="math inline">\(O(n\cdot 2^{k})\)</span>，是行不通的。</p>
<p>因为路径条数非常少，我们可以猜测本质不同的集合 <span
class="math inline">\(S_i\)</span> 的个数跟 <span
class="math inline">\(k\)</span> 是一个级别的。</p>
<p>证明可以考虑建出这 <span class="math inline">\(2k\)</span>
个点的虚树，由于虚树上最多只有 <span class="math inline">\(4k -
1\)</span> 个结点，<span class="math inline">\(4k - 2\)</span>
条边，所以最多只有 <span class="math inline">\(4k - 2\)</span>
种本质不同的 <span class="math inline">\(S_i\)</span>​。</p>
<p>有了上面的结论我们就可以直接 <span
class="math inline">\(O(nk)\)</span> 地 dp 了。</p>
<h2 id="参考代码">参考代码</h2>
<p><a
href="https://codeforces.com/contest/1929/submission/246624331">https://codeforces.com/contest/1929/submission/246624331</a></p>
]]></content>
      <categories>
        <category>Codeforces解题报告</category>
      </categories>
      <tags>
        <tag>虚树</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】ARC171C - Swap on Tree</title>
    <url>/2024/02/06/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91ARC171C/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://atcoder.jp/contests/arc171/tasks/arc171_c">https://atcoder.jp/contests/arc171/tasks/arc171_c</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定一颗 <span class="math inline">\(N\)</span>
个节点的树，初始时编号为 <span class="math inline">\(i\)</span>
的物品放在编号为 <span class="math inline">\(i\)</span> 的节点上。</p>
<p>你可以进行以下操作任意多次（可以为 <span
class="math inline">\(0\)</span> 次）：</p>
<ul>
<li>选择一条未被删除的边，假设这条边的两个端点编号分别为 <span
class="math inline">\(u,v\)</span>，交换节点 <span
class="math inline">\(u, v\)</span> 上的物品，并且将这条边删除。</li>
</ul>
<p>设 <span class="math inline">\(a_i\)</span> 为最终编号为 <span
class="math inline">\(i\)</span>
的节点上的物品编号，那么通过上述操作能形成多少种不同的序列 <span
class="math inline">\((a_1, a_2, \dots, a_n)\)</span>，答案对 <span
class="math inline">\(998244353\)</span> 取模。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(1\le N \le 3\times 10^{3}\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p>首先，如果选择的边集不同，那么最终的结果序列一定不同；如果选择的边集相同，那么最终的结果序列有可能相同，也有可能不同。</p>
<p>先从最简单的菊花图的形状开始考虑，假设中间一个节点周围连接了 <span
class="math inline">\(deg\)</span>
个节点，容易发现，最终结果序列相同，当且仅当两种选法选边的顺序是一致的，总共能得到
<span class="math inline">\(deg!\)</span> 种结果序列。</p>
<p>那如果是以 <span class="math inline">\(u\)</span> 和 <span
class="math inline">\(v\)</span>
为中心的两个菊花中间用一条边连接起来呢？那么最终结果序列相同，当且仅当两种选法中
<span class="math inline">\(u\)</span> 连接的边选择顺序相同，且 <span
class="math inline">\(v\)</span>​ 连接的边的选择顺序相同，总共能得到
<span class="math inline">\(deg_u! \times deg_{v}!\)</span>
种结果序列。</p>
<p>由于一棵树就是一堆小的菊花图连接起来的，所以上面的结论可以推广到整棵树上。即最终结果序列
<span class="math inline">\((a_1, a_2, \dots, a_n)\)</span>
相同，当且仅当两种选法分别对于树的每个节点 <span
class="math inline">\(u\)</span> 连接的边的选择顺序相同。</p>
<p>有了以上结论，假设最终选择的边集为 <span
class="math inline">\(S\)</span>，对于树上的每个节点 <span
class="math inline">\(u\)</span> 统计度数 <span
class="math inline">\(deg_u\)</span>，那么 <span
class="math inline">\(S\)</span> 对答案的贡献为 <span
class="math inline">\(\displaystyle\prod_{i = 1}^{n}
deg_i\)</span>。</p>
<p>考虑树形 dp 统计贡献，设 <span class="math inline">\(f_{u,
i}\)</span> 代表以 <span class="math inline">\(u\)</span>
为根的子树中，连接 <span class="math inline">\(u\)</span> 与 <span
class="math inline">\(u\)</span> 的儿子的边总共选了 <span
class="math inline">\(i\)</span> 条，对答案的总贡献。设 <span
class="math inline">\(g_{u, 0/1}\)</span> 代表连接 <span
class="math inline">\(u\)</span> 和 <span
class="math inline">\(u\)</span> 的父亲的边是否选了对答案的总贡献。</p>
<p>枚举 <span class="math inline">\(u\)</span> 的儿子 <span
class="math inline">\(v\)</span> 时，有转移 <span
class="math inline">\(f_{u, i} \leftarrow f_{u, i - 1} \times g_{v,
1}\)</span>，<span class="math inline">\(f_{u, i} \leftarrow f_{u, i}
\times g_{v, 0}\)</span>，<span class="math inline">\(g_{u, 0} = \sum
f_{u, i} \times i!\)</span>，<span class="math inline">\(g_{u, 1} = \sum
f_{u, i} \times (i + 1)!\)</span>。</p>
<p>最终答案为 <span class="math inline">\(g_{1,
0}\)</span>（假设整棵树以节点 <span class="math inline">\(1\)</span>
为根）。</p>
<h2 id="参考代码">参考代码</h2>
<p><a
href="https://atcoder.jp/contests/arc171/submissions/50056781">https://atcoder.jp/contests/arc171/submissions/50056781</a></p>
]]></content>
      <categories>
        <category>AtCoder解题报告</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>动态规划</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】CF1925F - Fractal Origami</title>
    <url>/2024/02/02/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91CF1925F/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://codeforces.com/contest/1925/problem/F">https://codeforces.com/contest/1925/problem/F</a></p>
<h2 id="题目大意">题目大意</h2>
<p><img
src="https://espresso.codeforces.com/1bf93f34e8055ab56549c4ec1ea686c047564085.png" /></p>
<p>将一个边长为 <span class="math inline">\(1\)</span>
的正方形按如图所示的方法进行 <span class="math inline">\(N\)</span>
次折叠（上图为 <span class="math inline">\(N = 2\)</span>
的情况），折叠之后展开。</p>
<p>展开后的折痕分为两种，一种是向内凹陷的折痕，总长度记为 <span
class="math inline">\(V\)</span>，另外一种是向外凸出的折痕，总长度记为
<span class="math inline">\(M\)</span>。</p>
<p>可以证明 <span class="math inline">\(\displaystyle\frac{M}{V} = A +
B\sqrt{2}\)</span>，其中 <span class="math inline">\(A,B\)</span>
均为有理数。求 <span class="math inline">\(B\)</span> 对 <span
class="math inline">\(999\text{ }999\text{ }893\)</span>
取模的结果。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(1\le N \le 10^{9}\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p>直接拿张纸来手动折几次，经过观察和推理不难发现下列性质：</p>
<ul>
<li><p>所有凹陷的折痕全都是在奇数层产生的，所有凸出的折痕全都是在偶数层产生的。</p></li>
<li><p>第 <span class="math inline">\(i\)</span> 次折叠前纸片总共有
<span class="math inline">\(2^{i - 1}\)</span>
层，折叠时对每一层产生总长度为 <span
class="math inline">\(\displaystyle\frac{1}{(\sqrt{2})^{i}}\)</span>​
的折痕。</p></li>
</ul>
设奇数层的折痕总长度为 <span
class="math inline">\(4L_1\)</span>，偶数层的折痕总长度为 <span
class="math inline">\(4L_2\)</span>，根据以上性质能够得到： $$
<span class="math display">\[\begin{aligned}

L_{1} &amp;= \frac{1}{\sqrt{2}} + \frac{1}{(\sqrt{2})^{2}}\times 2^{0} +
\frac{1}{(\sqrt{2})^{3}}\times 2^{1} + \cdots +
\frac{1}{(\sqrt{2})^{n}}\times 2^{n - 2} = (\sqrt{2})^{n} +
(\sqrt{2})^{n - 1} - 1  \\

L_{2} &amp;= \frac{1}{(\sqrt{2})^{2}}\times 2^{0} +
\frac{1}{(\sqrt{2})^{3}}\times 2^{1} + \cdots +
\frac{1}{(\sqrt{2})^{n}}\times 2^{n - 2} = (\sqrt{2})^{n} +
(\sqrt{2})^{n - 1} - \sqrt{2}- 1 \\

\end{aligned}\]</span>
<p>$$ 我是直接暴力推 <span
class="math inline">\(\displaystyle\frac{L_{2}}{L_{1}}\)</span> 算出来
<span class="math inline">\(B\)</span> 的，实际上不用那么麻烦。</p>
<p>实现一个 <span class="math inline">\(a + b\sqrt{2}\)</span>
的类，重载一下加减乘除运算即可，这样省下了推式子的时间，而且还不容易出错。</p>
<h2 id="参考代码">参考代码</h2>
<p><a
href="https://codeforces.com/contest/1925/submission/244500846">https://codeforces.com/contest/1925/submission/244500846</a></p>
]]></content>
      <categories>
        <category>Codeforces解题报告</category>
      </categories>
      <tags>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>ABC335G - Discrete Logarithm Problems</title>
    <url>/2024/01/17/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91ABC335G/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://atcoder.jp/contests/abc335/tasks/abc335_g">https://atcoder.jp/contests/abc335/tasks/abc335_g</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定 <span class="math inline">\(n\)</span> 个正整数 <span
class="math inline">\(a_1,a_2,\cdots,a_n\)</span> 和一个素数 <span
class="math inline">\(P\)</span>。求满足以下条件的二元组 <span
class="math inline">\((i,j)\)</span> 的个数。</p>
<ul>
<li><p><span class="math inline">\(1\leq i,j\leq N\)</span> 。</p></li>
<li><p>存在正整数 <span class="math inline">\(k\)</span> ，使得 <span
class="math inline">\(A_i^k\equiv A_j\pmod P\)</span>。</p></li>
</ul>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(1\le n\le 2\times 10^{5}\)</span></li>
<li><span class="math inline">\(1\le a_i &lt; P\)</span></li>
<li><span class="math inline">\(2 &lt; P \le 10^{13}\)</span> 且 <span
class="math inline">\(P\)</span> 是素数</li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p>考虑同余式 <span class="math inline">\(x^k \equiv y \pmod P\)</span>
能推出什么结论。</p>
<p>令 <span class="math inline">\(\delta_{P}(x)\)</span> 表示 <span
class="math inline">\(x\)</span> 在模 <span
class="math inline">\(P\)</span> 意义下的阶，因为 <span
class="math inline">\(x^k\)</span> 和 <span
class="math inline">\(y\)</span> 在模 <span
class="math inline">\(P\)</span> 意义下同余，所以一定有 <span
class="math inline">\(\delta_{P}(x^{k}) = \delta_P(y)\)</span> 。</p>
<p>其实以上的转化是我看题解看到的，至于应该怎么想才能自然地想到这一步，感觉需要一定的数学直觉，并且需要靠多做题积累经验。</p>
<p>根据阶的性质，有 <span class="math inline">\(\delta_{P}(x^{k}) =
\displaystyle\frac{\delta_{P}(x)}{\gcd(k, \delta_{P}(x))}\)</span>
，所以可以得到 <span class="math inline">\(\delta_{P}(x) = \gcd(k,
\delta_{P}(x)) \cdot \delta_{P}(y)\)</span>
，所以我们能推出一个必要条件</p>
$$
<span class="math display">\[\begin{aligned}

\exists{k \in \mathbb{N}} , x^{k} \equiv y \pmod P \implies
\delta_{P}(y) \mid \delta_{P}(x)

\end{aligned}\]</span>
<p>$$</p>
<p>那么该条件的充分性是否成立呢。</p>
<ul>
<li><p><strong>lemma 1</strong></p>
<p>如果 <span class="math inline">\(ta \equiv tb \pmod {tc}\)</span>
，则 <span class="math inline">\(a \equiv b \pmod c\)</span> 成立，其中
<span class="math inline">\(t,a,b\in \mathbb{N_{+}}\)</span> 。</p>
<p>证明非常简单，只需要把取模运算的表达式写出来即可证明。</p></li>
</ul>
<p>假设 <span class="math inline">\(g\)</span> 为 <span
class="math inline">\(P\)</span> 的一个原根，根据原根的性质，一定存在
<span class="math inline">\(e_1\)</span> 和 <span
class="math inline">\(e_2\)</span> 使得 <span
class="math inline">\(g^{e_1} \equiv x \pmod P\)</span> ，<span
class="math inline">\(g^{e_2} \equiv y \pmod
P\)</span>，两边取离散对数有 <span class="math inline">\(e_{1} \equiv
\operatorname{ind}_{g}(x) \pmod{P-1}\)</span> ，<span
class="math inline">\(e_{2} \equiv \operatorname{ind}_{g}(y) \pmod{P -
1}\)</span> 。我们要证 <span class="math inline">\(\exists{k \in
\mathbb{N}} , x^{k} \equiv y \pmod P\)</span> ，即证 <span
class="math inline">\(\exists{k \in \mathbb{N}} , ke_{1} \equiv e_2
\pmod{P-1}\)</span> 。</p>
<p>根据条件有</p>
$$
<span class="math display">\[\begin{aligned}

\delta_{P}(y) \mid \delta_{P}(x) \iff\delta_{P}(g^{e_2}) \mid
\delta_{P}(g^{e_1}) \iff \displaystyle\frac{P-1}{\gcd(e_2, P-1)} \mid
\displaystyle\frac{P-1}{\gcd(e_1, P-1)} \iff \gcd(e_1, P-1) \mid
\gcd(e_2, P-1)

\end{aligned}\]</span>
<p>$$</p>
<p>令 <span class="math inline">\(t = \gcd(e_1, P - 1)\)</span> ，根据
<strong>lemma 1</strong> 和要证的式子 <span
class="math inline">\(ke_{1}\equiv e_2 \pmod{P-1}\)</span> ，有</p>
$$
<span class="math display">\[\begin{aligned}

k\frac{e_1}{t} \equiv \frac{e_{2}}{t} \pmod{\frac{P-1}{t}}

\end{aligned}\]</span>
<p>$$</p>
<p>因为 <span
class="math inline">\(\displaystyle\frac{e_{1}}{t}\)</span> 与 <span
class="math inline">\(\displaystyle\frac{P-1}{t}\)</span>
互质，所以有</p>
$$
<span class="math display">\[\begin{aligned}

k\equiv \frac{e_{2}}{t} \cdot \left(\frac{e_1}{t}\right)^{-1}
\pmod{\frac{P-1}{t}}

\end{aligned}\]</span>
<p>$$</p>
<p>所以条件的充分性成立，即</p>
$$
<span class="math display">\[\begin{aligned}

\exists{k \in \mathbb{N}} , \text{ }x^{k} \equiv y \pmod P \implies
\delta_{P}(y) \mid \delta_{P}(x)

\end{aligned}\]</span>
<p>$$</p>
<p>接下来，考虑如何求一个数 <span class="math inline">\(a\)</span> 在模
<span class="math inline">\(P\)</span> 意义下的阶 <span
class="math inline">\(\delta_{P}(a)\)</span> 。因为 <span
class="math inline">\(\delta_{P}(a) \mid (P - 1)\)</span> ，并且若 <span
class="math inline">\(\delta_{P}(a) \mid b\)</span> ，那么 <span
class="math inline">\(x^{b} \equiv 1 \pmod P\)</span> 成立，所以可以先将
<span class="math inline">\(P - 1\)</span> 质因数分解，初始时令 <span
class="math inline">\(b = P - 1\)</span> ，每次选取一个质因数 <span
class="math inline">\(p\)</span> ，判断 <span class="math inline">\(x ^
{\frac{b}{p}} \equiv 1 \pmod P\)</span> 是否成立，成立则将 <span
class="math inline">\(p\)</span>
除掉，不成立就取下一个质因数做相同的操作，这样最后得到的 <span
class="math inline">\(b\)</span> 就是 <span
class="math inline">\(a\)</span> 的阶。对于给定序列的每一个 <span
class="math inline">\(a_i\)</span> 做一遍上述操作的时间复杂度为 <span
class="math inline">\(O(\sqrt{P} + n \log^{2} P)\)</span> 。</p>
<p><img
src="https://cdn.luogu.com.cn/upload/image_hosting/3ok46vsq.png" /></p>
<p>根据上表，我们发现 <span class="math inline">\(P - 1\)</span>
的约数个数的级别不超过 <span class="math inline">\(10^4\)</span>
，所以可以直接 <span
class="math inline">\(O(\operatorname{d}(P)^{2})\)</span> 计算 <span
class="math inline">\(\delta_{P}(a_i)\)</span> 对答案的贡献。</p>
<p>所以总时间复杂度为 <span class="math inline">\(O(\sqrt{P} + n
\log^{2} P + \operatorname{d}(P)^{2})\)</span> ，时限为 <span
class="math inline">\(5\text{s}\)</span> ，可以通过本题。</p>
<h2 id="参考代码">参考代码</h2>
<p><a
href="https://atcoder.jp/contests/abc335/submissions/49356980">https://atcoder.jp/contests/abc335/submissions/49356980</a></p>
]]></content>
      <categories>
        <category>AtCoder解题报告</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>阶</tag>
        <tag>原根</tag>
        <tag>离散对数</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】ABC171F - Strivore</title>
    <url>/2023/12/15/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91ABC171F/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://atcoder.jp/contests/abc171/tasks/abc171_f">https://atcoder.jp/contests/abc171/tasks/abc171_f</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定一个长度为 <span class="math inline">\(n\)</span>
的由小写字母组成的字符串 <span class="math inline">\(s\)</span>
，每次操作任选一个位置插入任意一个小写字母，问进行恰好 <span
class="math inline">\(k\)</span>
次操作之后能得到多少种本质不同的字符串，答案对 <span
class="math inline">\(10^{9} + 7\)</span> 取模。</p>
<p>两个字符串本质不同，当且仅当长度不同或者至少有一个位置上的字母不同。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(1\le n, k \le 10^{6}\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p>不难想到，问题等价于有 <span class="math inline">\(n + k\)</span>
个位置，我们先找出 <span class="math inline">\(n\)</span>
个位置依次放上字符串 <span class="math inline">\(s\)</span>
的每一位，然后剩下的 <span class="math inline">\(k\)</span>
个位置每个随便选一个字母，能得到多少种本质不同的字符串。</p>
<p>很显然，这样简单粗暴的计算会导致答案统计重复。</p>
<p>如果从反向考虑，假设存在一个答案，我们如何通过一一映射的方法让它统计且恰好被统计一次。</p>
<p>考虑到，一个合法的方案，最终得到的长度为 <span
class="math inline">\(n + k\)</span> 的字符串，<span
class="math inline">\(s\)</span>
一定是它的一个子序列，假设最靠前出现的那个子序列对应的位置为 <span
class="math inline">\(p_1, p_2, \cdots, p_n\)</span> 。考虑枚举 <span
class="math inline">\(p_1, p_2, \cdots, p_n\)</span>
，钦定这些位置为最靠前出现的那个子序列，
选取剩下位置的小写字母时不破坏前面的性质，这样我们每个合法的答案只会被最靠前出现的那个子序列统计一次，这样就能不重不漏地统计了。</p>
<p>那么如何保证不破坏前面那条性质呢？</p>
<p>显然，只要在区间 <span class="math inline">\((0, p_1)\)</span>
上不要选取字母 <span class="math inline">\(s_{p_1}\)</span> ，区间 <span
class="math inline">\((p_1, p_2)\)</span> 上不要选取字母 <span
class="math inline">\(s_{p_2}\)</span> ，在区间 <span
class="math inline">\((p_2, p_3)\)</span> 上不要选取字母 <span
class="math inline">\(s_{p_3}\)</span> ，在区间 <span
class="math inline">\((p_{i - 1}, p_{i})\)</span> 上不要选取字母 <span
class="math inline">\(s_{p_i}\)</span> 即可。</p>
<p>考虑枚举最后一个放置字母的位置 <span class="math inline">\(i\)</span>
，根据上面的分析，在 <span class="math inline">\(i\)</span>
之前的每个空位，都只能选取 <span class="math inline">\(25\)</span>
个不同的小写字母，在 <span class="math inline">\(i\)</span>
之后的每个空位，可以选取 <span class="math inline">\(26\)</span>
个不同的小写字母，所以容易得到最终答案是</p>
$$
<span class="math display">\[\begin{aligned}

\sum\limits_{i = n} ^ {n + k} \binom{i - 1}{n - 1} 25^{i - n} 26^{n + k
- i}

\end{aligned}\]</span>
<p>$$</p>
<h2 id="参考代码">参考代码</h2>
<p><a
href="https://atcoder.jp/contests/abc171/submissions/48405143">https://atcoder.jp/contests/abc171/submissions/48405143</a></p>
]]></content>
      <categories>
        <category>AtCoder解题报告</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】CF1907G - Lights</title>
    <url>/2023/12/09/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91CF1907G/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://codeforces.com/contest/1907/problem/G">https://codeforces.com/contest/1907/problem/G</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的 <span
class="math inline">\(01\)</span> 串，有 <span
class="math inline">\(n\)</span> 个开关，按下第 <span
class="math inline">\(i\)</span> 个开关会反转位置 <span
class="math inline">\(i\)</span> 和位置 <span
class="math inline">\(a_i\)</span> 的状态（<span
class="math inline">\(a_i \neq i\)</span>），目标是让 <span
class="math inline">\(01\)</span> 串的状态变为全 <span
class="math inline">\(0\)</span> 。</p>
<p>报告无解，若有解，输出操作次数最少的方案。</p>
<h2 id="数据范围">数据范围</h2>
<p>多组测试数据，保证</p>
<ul>
<li><span class="math inline">\(\sum n \le 2\times 10^{5}\)</span></li>
<li><span class="math inline">\(1 \le a_i \le n, a_i \neq
i\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p>注意到每个开关控制且仅控制两个位置的状态，所以我们可以把开关抽象成<strong>边</strong>，把每个位置抽象成一个<strong>结点</strong>。</p>
<p>我们发现总共有 <span class="math inline">\(n\)</span> 个节点 <span
class="math inline">\(n\)</span>
条边，但是图不保证联通，所以建完图之后是一个基环树森林。</p>
<p>问题变为给定一个基环树森林，选择最小的边集，使得反转边集中所有边连接的两个结点的状态后，所有结点的状态都变为
<span class="math inline">\(0\)</span> 。</p>
<p>其实只需要考虑一个基环树上怎么做。</p>
<p>首先可以注意到这颗基环树上状态为 <span
class="math inline">\(1\)</span>
的结点个数必须为偶数个，否则肯定无解。</p>
<p>其次可以注意到一条边只会被选择 <span class="math inline">\(0\)</span>
次或者 <span class="math inline">\(1\)</span> 次，选择 <span
class="math inline">\(2\)</span> 次跟 <span
class="math inline">\(0\)</span>
次的结果相同，所以我们可以将基环树上的环断掉，比一下选断掉的边和不选断掉的边哪个更优即可。</p>
<p>于是只需要考虑在一颗树上怎么做。</p>
<p>先假设只有两个状态为 <span class="math inline">\(1\)</span>
的结点，显然最小的边集一定是两点简单路径上所有的边。</p>
<p>假设有四个呢？如果我们随便两两配对，发现路径可能有交集，这样是不优的，但是我们发现只要把路径交集去掉不选，剩下的不交的部分又构成两条新的路径，这样一定是最优的。</p>
<p>所以到此为止此题基本结束，我们只需要按照任意顺序给状态为 <span
class="math inline">\(1\)</span>
的结点配对，把所有配对的点对的路径上所有边的值加 <span
class="math inline">\(1\)</span>
，最后选择值为奇数的边即为最优方案。</p>
<p>用树上差分加上倍增求 lca 实现的话为 <span
class="math inline">\(O(n\log n)\)</span> ，瓶颈为倍增求 lca 。</p>
<h2 id="参考代码">参考代码</h2>
<p><a
href="https://codeforces.com/contest/1907/submission/236342135">https://codeforces.com/contest/1907/submission/236342135</a></p>
]]></content>
      <categories>
        <category>Codeforces解题报告</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>基环树</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC2023深圳站【游记】</title>
    <url>/2023/11/17/%E3%80%90%E6%B8%B8%E8%AE%B0%E3%80%91CCPC2023%E6%B7%B1%E5%9C%B3%E7%AB%99%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>省流：</strong></p>
<ul>
<li><strong>队名：</strong> 可导必可积，积完要加C</li>
<li><strong>题数：</strong> <span class="math inline">\(5\)</span></li>
<li><strong>罚时：</strong> <span
class="math inline">\(1167\)</span></li>
<li><strong>排名(offical)：</strong> <span
class="math inline">\(\textcolor{brown}{83} / 240\)</span></li>
<li><strong>奖牌：</strong> <strong><span
class="math inline">\(\textcolor{brown}{铜}\)</span></strong></li>
</ul>
<h1 id="day--1">Day -1</h1>
<p><strong>11.10</strong></p>
<p>赛季最后一战了，前两战桂林和南京分别收获了 1 铁 1 铜。</p>
<p>这场我们是三个大一新生组的队，我的两个队友之前是中强省省一水平的 oier
，我之前是中等偏弱省省一水平的 oier
，论阵容的理论实力还是比前两场要高一些的，特别其中一个队友还是今年西安站乱搞搞出了校史第一块
xcpc 区域赛 Au 的 NewIntown 神，下面简称 N 神，另外一个队友是 HN
热爱多项式的前知名 oier【】的同学 warzone 神，下面简称王总。</p>
<p>u1s1，这是我们上限最高的一集，同时也可能是下限最低的一集，因为我们从来没有一起练过，到时候机子怎么分还是个问题。</p>
<span id="more"></span>
<h1 id="day-0">Day 0</h1>
<p><strong>11.11</strong></p>
<p>上午签到领物资，
深圳技术大学给的物资是真的顶，这里必须吹一波，至于多么富，放一张图就知道了（不是我拍的，应该是比赛组织拍着玩的）。</p>
<p><img src="https://z1.ax1x.com/2023/11/17/pitWwHU.jpg" /></p>
<p>有咖啡杯，中间的一堆 F5 键是咖啡（F5 刷新键寓意 refresh your
life），此外每人还有一件精美的长袖。</p>
<h1 id="day-1">Day 1</h1>
<p><strong>11.12</strong></p>
<p>早上 9 : 00 正式比赛开始。</p>
<p>开局我们各自开题，N 神看了 D 题，王总看到 H
题“快速散列变换”瞬间起了兴趣，开始推导，我在盯榜并且寻找签到题。</p>
<p>20min 时，我找到签到题 F 了，N 神这时说他会 D 题了，为了抢 D
题一血，电脑先让给 N 神写 D 题。</p>
<p>但是 N 神的思路好像假了一部分，在调试一段时间并且连 WA
三发无果之后，电脑便让给我写 F 签到。</p>
<p>但最害怕的事情还是发生了，写 F
的时候心里非常着急，写完之后取栈中两个元素
<code>x = st[i % m], y = st[(i + 1) % m]</code> 写成了
<code>x = i % m, y = (i + 1) % m</code>
，我还以为是找基环树的环找错了，盯了半天代码也没盯出错来，此时已经 1h
左右了。</p>
<p>这时 N 神说 L
题是一个简单的期望题，说马上就能写完，于是我又把机子让给他写 L
题，他写了 10min 又调了 10min
发现第二个样例过不去，得出结论是他式子推错了。</p>
<p><strong>至此，我们队开局彻底爆炸。</strong></p>
<p>还好王总在我们调代码时把 A 看过一遍，在 N 神放弃调 L
的时候，他上去瞬间把 A 切掉了，稳定了一下军心，不过这时候比赛已经过去
84min 了，我们才刚刚通过一个题，这让我们心态很崩。</p>
<p>此时 N 神在不断思考 D 题和 L 题怎么错了，王总在说 H
题他有思路但不知道时间复杂度对不对，索性暂时放弃，又去推导一眼 EI 的 B
题，我仍然在思考 F 的代码哪错了。</p>
<p>大家都毫无进展，我在重构 F 题代码的时候发现了上面说的神秘错误，在
150min 的时候把 F
过了，此时比赛时间过半，我们队只过了两题，由于开局爆炸，进而导致心态不顺，我们还处在铁牌区。</p>
<p>之后 3h
的时候我们看了一眼榜，觉得再这么下去不行了，大家压在手里的都是一堆不可做题，于是王总把推不动的多项式先扔掉去看
I ，N 神看了一眼 M 发现可以乱搞，我去看 N 神推错式子的 L
题，顺便跟王总讨论了一下 G 题的做法。</p>
<p><strong>但是封榜之前我们依旧没过更多的题。</strong></p>
<p>说实话当时的我已经做好打铁的准备了，但是封榜之后我的队友犹如神助。</p>
<p>N 神先是 10min 把 G 题搞定并且 1
发通过了，王总又调出来了他写了将近一个小时的 I 题，也是 1 发通过。</p>
<p>5分钟之内连过两题让我们信心大增，N 神又继续去调他乱搞的 M
题，他说用压位高精写这个在遇到一些情况的时候特别难搞，在 WA 了 3
发调不出来之后，直接把压位改成了一位一位来，结果没想到 <span
class="math inline">\(O(n^2 k)\)</span> 加各种剪枝优化直接 1s
之内跑过去了 <span class="math inline">\(n = 500, k = 2 \times
10^4\)</span> 。</p>
<p>至此，我们封榜之后过了 3
题，比我们封榜之前过的还多，唯一可惜的就是我们 L
题的式子到最后推的还是有一点错误的，遗憾没有通过 L 题。</p>
<p>最后，我靠着队友 N 神和王总的血C，封榜之后连续拿下 3 题，取得了 5
题最后一名的结局，排名是正式队 rk83，差点拿下 Ag
，奈何开局爆炸罚时太大，奈何我没有找出 L
题推的式子的错误，遗憾还是很多的。</p>
<p><strong>颁奖典礼</strong></p>
<p>dls 作为特邀嘉宾来深圳参赛了，不出意外带队打了第一（差一题 AK）。</p>
<p>顽强拼搏奖居然是 dls
亲自颁发，还合影留念，那一队看似输麻，实则赢麻！</p>
<p><strong>赛后总结</strong></p>
<p>我完全没有发挥，纯靠队友带。</p>
<p>多练！多想！多打比赛！</p>
<p><strong>放张图纪念一下</strong></p>
<p><img src="https://z1.ax1x.com/2023/11/17/pitWcg1.jpg" /></p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>QwQ</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC2023桂林站【游记】</title>
    <url>/2023/11/08/%E3%80%90%E6%B8%B8%E8%AE%B0%E3%80%91CCPC2023%E6%A1%82%E6%9E%97%E7%AB%99%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>省流：</strong></p>
<ul>
<li><strong>队名：</strong> 无名</li>
<li><strong>题数：</strong> <span class="math inline">\(3\)</span></li>
<li><strong>罚时：</strong> <span
class="math inline">\(464\)</span></li>
<li><strong>排名(offical)：</strong> <span
class="math inline">\(\textcolor{red}{148}/240\)</span></li>
<li><strong>奖牌：</strong> <strong><span
class="math inline">\(\textcolor{red}{铁}\)</span></strong></li>
</ul>
<span id="more"></span>
<h1 id="day--1">Day -1</h1>
<p><strong>10.27</strong></p>
<p>大学第一场 xcpc ，有些小激动。</p>
<p>经历了一天的颠簸，晚上终于坐飞机到桂林了，刷新了从小到大到达过的最南边和最西边的记录。</p>
<p>不愧于“桂林山水甲天下”的美誉，桂林的喀斯特地貌几乎随处可见，小城周围环绕的山地总能给人一种与世隔绝的安宁。</p>
<p>高中神仙同学核仁好像也来桂林站，明天就可以面基了，耶！</p>
<h1 id="day-0">Day 0</h1>
<p><strong>10.28</strong></p>
<p>早上领到了桂林站主办方准备的桂林特产。</p>
<p>中午吃到了桂林本地的螺狮粉（其实这是我第一次吃螺狮粉），我也不知道这是不是正宗的螺狮粉，反正跟臭豆腐差不多，制作过程中闻起来挺臭，但吃起来一点也不臭。</p>
<p>下午热身赛。</p>
<p>到了桂林电子科技大学之后，感觉东秦直接被吊打得体无完肤/ll。虽然桂电有地理位置的优势，四面环山环境优美，而且地还巨大，这些东秦没法比，但是为啥东秦的硬件被吊锤成这样，经费呢？？？？？？？？</p>
<p>进场之后，由于我第一次使用 ubuntu 系统，并且没怎么用过 vscode 和
code_blocks，更致命的是最有经验的大三队友还没到，另外一个队友也没用过，所以我们研究编译研究了好久，结果热身赛快结束的时候被同校的另外一支队伍告知是文件夹建在了中文目录下导致编译不了/tuu。</p>
<p>最后热身赛只惨淡地过了一道题。</p>
<p>面基了 He_Ren，他跟 ix35 和等腰三角形一队，三个 Au
爷热身赛直接虐杀全场，甚至吊打了 jls 领衔的菜狗（恐怖如斯）。</p>
<h1 id="day-1">Day 1</h1>
<p><strong>10.29</strong></p>
<p>开场十分紧张。</p>
<p>队友先看到了签到题 G ，结果上来 WA
了一发，更慌了，还好马上发现错误之后过了，然后我看了一眼 M
题不是很会，过了一会看榜发现 M 好像是个签到题，又回来想
M，脑子一热想错了一个条件，反复跟队友确认之后发现自己漏了一个条件想假了，又讨论了一会发现是个二分加最大子段和，然后带着慌张的情绪写写写，写完又出了好几个bug，不过还好调过样例之后就过了。</p>
<p>然后此时队友说 B 有思路，提议看 B
题，然后觉得队友想法很对，但是细节上有些乱，然后就写写写，发现有一种很重要的情况没有判断，然后开始改改改，中间浪费了很长时间，但样例还是一直过不去，心态已经开始炸了。</p>
<p>大概 2.5h 左右，B题实在调不出来了，选择开 K
题，很快发现是一个将数据范围分成两部分分别暴力，但是不管怎么写样例都能过，交上去还一直炸裂，就这样磨了
1
个多小时，心态已经被磨到不行了，最后队友发现是置换进行运算时不能交换，我做置换运算的时候做反了/ll。</p>
<p>此时我们在铜牌垫底区，队友继续在调 B
题，但我当时心态已经炸裂到不知道该干啥了，于是去跟榜看 I
题。我努力试图让自己冷静下来，经过不久的思考，我把 I
题的题意转化成一堆询问，每次询问求区间颜色数，这是一个非常经典的问题，但此时离比赛结束还有
45min，我不知所措根本没有时间静下心来（其实也怪我菜，心理素质还差），居然没想到可以离线树状数组做，然后队友说可以主席树（但他在调
B
，显然没有时间过来帮我写），我一想也是，但已经完全忘记怎么写了，于是我就一直打摆打到比赛结束。</p>
<p>最后 3 题遗憾打铁，属于是自费出来旅游了。（差 5 名 Cu）/大哭</p>
<p>真是应了那句话“期望越大，失望越大”。</p>
<p>究其原因，大概有以下几点：</p>
<ul>
<li><p><strong>队伍磨合差</strong></p>
<p>其实按照实力来讲，我们队应该至少能过 5
题，但赛前除了两场挂一场的预选赛，队伍从来没有在一起打过别的比赛，队内化学反应很差，根本磨合不起来。</p></li>
<li><p><strong>自己水平不够</strong></p>
<p>自己疏于算法竞赛一年多，本来就是个弱省省一水平，现在更菜了</p></li>
<li><p><strong>怯场+心态不平稳</strong></p>
<p>第一次线下赛怯场导致无法将自己实力全部发挥</p></li>
</ul>
<p>还是要多 vp CF Edu 和 ARC
的比赛提升个人的思维和代码水平，并且通过和队友一起 vp xcpc
真题来提升队伍磨合。</p>
<p>最后膜拜一下高中同学 He_Ren 领衔的清华大学 world.search(you) 队，与
jls 领衔的菜狗队同题数，但罚时遥遥领先，成功在 jls 头上摘冠。Orz Orz Orz
Orz</p>
<p>什么时候我才能有 He_Ren <span
class="math inline">\(\frac{1}{10}\)</span> 的实力啊！！！</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>QwQ</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC2023南京站【游记】</title>
    <url>/2023/11/08/%E3%80%90%E6%B8%B8%E8%AE%B0%E3%80%91ICPC2023%E5%8D%97%E4%BA%AC%E7%AB%99%E6%B8%B8%E8%AE%B0/</url>
    <content><![CDATA[<p><strong>省流：</strong></p>
<ul>
<li><strong>队名：</strong> 无名</li>
<li><strong>题数：</strong> <span class="math inline">\(5\)</span></li>
<li><strong>罚时：</strong> <span
class="math inline">\(625\)</span></li>
<li><strong>排名(offical)：</strong> <span
class="math inline">\(\textcolor{brown}{106} / 331\)</span></li>
<li><strong>奖牌：</strong> <strong><span
class="math inline">\(\textcolor{brown}{铜}\)</span></strong></li>
</ul>
<h1 id="day--">Day -?</h1>
<p>上场打桂林的那个队伍的大三学长因为有事，这场打不了，我们队招募来了一个新的大一佬
wyx ，并且 vp 了七八场历年的 xcpc
真题，平均位次在铜牌首部到银牌中部。</p>
<p>鉴于桂林打铁的教训，我们非常重视队伍的磨合以及做题策略，赛前一直在做积极的心理暗示。</p>
<h1 id="day--1">Day -1</h1>
<p><strong>11.03</strong></p>
<p>坐高铁从秦皇岛到了南京，因为酒店位置有点偏，没有吃到当地有名的鸭血粉丝汤。</p>
<p>另外一队的大一佬 warzone 过来提醒我们今晚有 CF
Edu，于是就直接开打，过了 ABCD 题，E
题读了题但没啥时间，索性不想直接睡觉了，毕竟第二天还挺忙的。</p>
<span id="more"></span>
<h1 id="day-0">Day 0</h1>
<p><strong>11.04</strong></p>
<p>中午到了南京航空航天大学。</p>
<p>居然有校园巴士，狠狠羡慕了。</p>
<p>乘坐校园巴士到体育馆领了南京站的外套（巨好看，上面还印着 Floyd
最短路的代码），并且合了个影。然后就是到南航的食堂吃午饭，忘记第几食堂了，反正看门口的招牌，感觉跟到了饭店一样，25
块钱的餐券根本花不完。</p>
<p>吃完饭闲的没事干跑去篮球场看看，结果还真有球卡在球框和板之间了，用矿泉水瓶砸下来然后开始和队友投篮，过了一会还来了一个国防科技大学的佬来一起打，这下成物理热身了（</p>
<p>然后就是下午的热身赛，题目是前几年的四个南京站原题，还得知热身赛和正赛都有中文题面（好耶）。南京站的硬件配置也属实顶级，果然有钱就是好，南京站独有的经典袋鼠吉祥物每个队伍也有（i了i了）。</p>
<p>傍晚的时候回来看了一眼昨晚 CF 的榜 rk500 多，rating 大概涨了 40
分左右。</p>
<h1 id="day-1">Day 1</h1>
<p><strong>11.05</strong></p>
<p>开场依然有点紧张，但还是一直哼唱周董的歌努力让自己平静下来。</p>
<p>三人分别从头、尾和中间开始看题，我还负责盯榜，然后发现 I
是签到，但是求稳还是写得很慢，防止出错，20min 时一发过了。</p>
<p>然后看榜发现 G 和 C 是目前最可做的题。</p>
<p>我先想了 G
题，凭感觉加简单证明，就是把物品按体积排序之后，从头部和尾部分别写两个背包，然后枚举一下两个背包分开的位置，结果第一发
WA 了，以为思路假了，结果发现是背包写出了小锅，改完马上过了。</p>
<p>然后 wyx C
题有思路了，经过简短的讨论之后发现很真，然后开始码，过了样例之后一发过了。</p>
<p>过了一会，大二队友 F
题有思路了，三个人探讨了一下细节，然后我接着开始码，然后又直接一发过了。</p>
<p>到目前位置很顺，感觉赛前的磨合还是很有用的，三个队友分别看 A , L ,
M。</p>
<p>我看完 M 没啥思路，于是去跟队友探讨 L
题，然后讨论出了很真的贪心的思路，就是代码不太好写，码了很久才码完，样例也调了很久，最后交上去还
WA 了，然后对着代码瞪了半个小时没看出一点错。这个时候 wyx A
题出思路了，于是我把代码打印出来开始调，他开始码 A 。</p>
<p>此时已经封榜了，时间比较紧，我对着大二队友开始了小黄鸭调试法，大概过了半个小时发现一个减号的前后写反了，立马反过来，交了一发直接过了。</p>
<p>此时过了 5 题，以为绝杀拿 Ag
了，可惜队友时间不够用了，A题没调出来，否则就是稳 Ag 了。</p>
<p>可惜最后不尽人意，滚榜被滚到了铜首，差 8 名 Ag
，不过还好终于有牌子了。</p>
<p>还是一句话：个人水平不够，还得加油练啊！！！</p>
<hr />
<p>留两张图，算是纪念一下</p>
<p><img src="https://z1.ax1x.com/2023/11/08/pi1jZHP.jpg"
alt="pi1jZHP.jpg" /> <img
src="https://z1.ax1x.com/2023/11/08/pi1jnN8.jpg"
alt="pi1jnN8.jpg" /></p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>QwQ</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】ARC167D - Good Permutation</title>
    <url>/2023/10/20/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91ARC167D/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://atcoder.jp/contests/arc167/tasks/arc167_d">https://atcoder.jp/contests/arc167/tasks/arc167_d</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定一个 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 的排列 <span
class="math inline">\(P\)</span> 。</p>
<p>定义一个排列 <span class="math inline">\(Q\)</span>
为好排列当且仅当对于任意整数 <span class="math inline">\(1\le x \le
n\)</span> ，通过若干次赋值（可以为 <span
class="math inline">\(0\)</span> 次） <span class="math inline">\(x
\leftarrow Q_x\)</span> ，最终能够使得 <span
class="math inline">\(x\)</span> 变成 <span
class="math inline">\(1\)</span> 。</p>
<p>现在可以进行若干次操作，每次可以交换 <span
class="math inline">\(P\)</span> 的任意两个不同的位置。</p>
<p>假设最少进行 <span class="math inline">\(m\)</span> 次操作使得 <span
class="math inline">\(P\)</span> 成为一个好排列，求进行 <span
class="math inline">\(m\)</span> 操作之后 <span
class="math inline">\(P\)</span> 能够成为的字典序最小的好排列。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(\sum n \le 2 \times 10 ^
{5}\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p>（不想好好写了）</p>
<p>转化成 <span class="math inline">\(p_i \rightarrow i\)</span>
的图模型分析一下即可。</p>
<h2 id="参考代码">参考代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; suf[i];</span><br><span class="line">		pre[suf[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; circle, oth;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		oth.<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	oth.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (suf[x] != <span class="number">1</span>) &#123;</span><br><span class="line">		x = suf[x];</span><br><span class="line">		oth.<span class="built_in">erase</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">assert</span>(oth.<span class="built_in">find</span>(i) == oth.<span class="built_in">end</span>());</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (oth.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> mnx = *oth.<span class="built_in">begin</span>();</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		printf(&quot;i = %d, mnx = %d\n&quot;, i, mnx);</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (mnx &gt; suf[i] &amp;&amp; i + <span class="built_in">SZ</span>(oth) &lt; n) &#123;</span><br><span class="line"><span class="comment">//			printf(&quot;continue pos : %d\n&quot;, i);</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> cur = mnx;</span><br><span class="line">		oth.<span class="built_in">erase</span>(cur);</span><br><span class="line">		<span class="keyword">while</span> (suf[cur] != mnx) &#123;</span><br><span class="line">			cur = suf[cur];</span><br><span class="line">			oth.<span class="built_in">erase</span>(cur);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		suf[pre[mnx]] = suf[i];</span><br><span class="line">		pre[suf[i]] = pre[mnx];</span><br><span class="line">		</span><br><span class="line">		suf[i] = mnx;</span><br><span class="line">		pre[mnx] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	x = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ans[x] = suf[x];</span><br><span class="line">		x = suf[x];</span><br><span class="line">	&#125; <span class="keyword">while</span> (x != <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AtCoder解题报告</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】ICPC2021沈阳站 L - Perfect Matchings</title>
    <url>/2023/10/19/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91ICPC2021%E6%B2%88%E9%98%B3%E7%AB%99%20L%20-%20Perfect%20Matchings/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://codeforces.com/gym/103427/problem/L">https://codeforces.com/gym/103427/problem/L</a></p>
<h2 id="题目大意">题目大意</h2>
<p>有一个 <span class="math inline">\(2n\)</span>
个点的完全图，给出这个完全图的一颗生成树，从完全图上删去树上的边，求剩下的图的完美匹配的方案数。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(2 \le n \le 2000\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p><img src="https://z1.ax1x.com/2023/10/19/piiGp7t.png" /> <img
src="https://z1.ax1x.com/2023/10/19/piiGS0I.png" /></p>
<h2 id="参考代码">参考代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">	sz[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	dp[u][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(tmp, dp[u], <span class="built_in">sizeof</span>(dp[u]));</span><br><span class="line">		<span class="built_in">memset</span>(dp[u], <span class="number">0</span>, <span class="built_in">sizeof</span>(dp[u]));</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= sz[u] / <span class="number">2</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= sz[v] / <span class="number">2</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!dp[v][j][<span class="number">0</span>]) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			</span><br><span class="line">				<span class="keyword">if</span> (tmp[i][<span class="number">0</span>]) &#123;</span><br><span class="line">					<span class="built_in">add_mod</span>(dp[u][i + j][<span class="number">0</span>], <span class="number">1ll</span> * tmp[i][<span class="number">0</span>] * dp[v][j][<span class="number">0</span>] % Mod);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (tmp[i][<span class="number">0</span>]) &#123;</span><br><span class="line">					<span class="built_in">add_mod</span>(dp[u][i + j + <span class="number">1</span>][<span class="number">1</span>], <span class="number">1ll</span> * tmp[i][<span class="number">0</span>] * dp[v][j][<span class="number">0</span>] % Mod);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (tmp[i][<span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="built_in">add_mod</span>(dp[u][i + j][<span class="number">1</span>], <span class="number">1ll</span> * tmp[i][<span class="number">1</span>] * dp[v][j][<span class="number">0</span>] % Mod);</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= sz[v] / <span class="number">2</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!dp[v][j][<span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (tmp[i][<span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="built_in">add_mod</span>(dp[u][i + j][<span class="number">1</span>], <span class="number">1ll</span> * tmp[i][<span class="number">1</span>] * dp[v][j][<span class="number">1</span>] % Mod);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (tmp[i][<span class="number">0</span>]) &#123;</span><br><span class="line">					<span class="built_in">add_mod</span>(dp[u][i + j][<span class="number">0</span>], <span class="number">1ll</span> * tmp[i][<span class="number">0</span>] * dp[v][j][<span class="number">1</span>] % Mod);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sz[u] += sz[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">		G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">		fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">	&#125; </span><br><span class="line">	invf[<span class="number">2</span> * n] = <span class="built_in">inv</span>(fac[<span class="number">2</span> * n]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		invf[i] = <span class="number">1ll</span> * invf[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % Mod;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * n; i += <span class="number">2</span>) &#123;</span><br><span class="line">		f[i] = <span class="number">1ll</span> * fac[i] * <span class="built_in">inv</span>(<span class="built_in">ksm</span>(<span class="number">2ll</span>, i / <span class="number">2</span>)) % Mod * invf[i / <span class="number">2</span>] % Mod;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		g[i] = <span class="number">1ll</span> * (dp[<span class="number">1</span>][i][<span class="number">0</span>] + dp[<span class="number">1</span>][i][<span class="number">1</span>]) * f[<span class="number">2</span> * (n - i)] % Mod;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> ans = f[<span class="number">2</span> * n];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> add = g[i];</span><br><span class="line">		<span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			add = Mod - add;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = (ans + add) % Mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>XCPC解题报告</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
        <tag>动态规划</tag>
        <tag>树形背包</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】ICPC2021沈阳站 M - String Problem</title>
    <url>/2023/10/15/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91ICPC2021%E6%B2%88%E9%98%B3%E7%AB%99%20M%20-%20String%20Problem/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://codeforces.com/gym/103427/problem/M">https://codeforces.com/gym/103427/problem/M</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定小写字母构成的字符串 <span class="math inline">\(S\)</span>
，对于 <span class="math inline">\(S\)</span>
的每个前缀，求该前缀的所有子串中字典序最大且出现位置最靠左的子串的左右端点。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(1 \le |S| \le 10^6\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p><img src="https://z1.ax1x.com/2023/10/15/pi9XYUH.png" /> <img
src="https://z1.ax1x.com/2023/10/15/pi9X3DO.png" /> <img
src="https://z1.ax1x.com/2023/10/15/pi9XJVe.png" /> <img
src="https://z1.ax1x.com/2023/10/15/pi9X8bD.png" /></p>
<h2 id="参考代码">参考代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> SA :: sa;</span><br><span class="line"><span class="keyword">using</span> SA :: rk;</span><br><span class="line"><span class="keyword">using</span> SA :: height;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"><span class="type">int</span> st[MAXN][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> h[MAXN], pos[MAXN];</span><br><span class="line"><span class="type">int</span> lg2[MAXN];</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; S;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> s = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(st[l][s], st[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qlmax</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> it = S.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">	<span class="keyword">if</span> (it == S.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> *(--it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">	n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	SA::<span class="built_in">init</span>(s, n);</span><br><span class="line">	</span><br><span class="line">	lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		st[i][<span class="number">0</span>] = height[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">			st[i][j] = <span class="built_in">min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	h[rk[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">	S.<span class="built_in">insert</span>(rk[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> r = rk[i];</span><br><span class="line">		<span class="type">int</span> l = <span class="built_in">qlmax</span>(r);</span><br><span class="line">		<span class="keyword">if</span> (l == <span class="number">-1</span>) &#123;</span><br><span class="line">			h[r] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			h[r] = <span class="built_in">query</span>(l + <span class="number">1</span>, r);</span><br><span class="line">		&#125;</span><br><span class="line">		S.<span class="built_in">insert</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n, r = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">		<span class="type">int</span> x = sa[i] + h[i];</span><br><span class="line">		<span class="keyword">while</span> (r &gt;= x) &#123;</span><br><span class="line">			pos[r] = sa[i];</span><br><span class="line">			r--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, pos[i], i);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>XCPC解题报告</category>
      </categories>
      <tags>
        <tag>字符串算法</tag>
        <tag>后缀排序</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】CCPC2021威海站 M - 810975</title>
    <url>/2023/10/11/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91CCPC2021%E5%A8%81%E6%B5%B7%E7%AB%99%20M%20-%20810975/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://codeforces.com/gym/103428/problem/M">https://codeforces.com/gym/103428/problem/M</a></p>
<h2 id="题目大意">题目大意</h2>
<p>一个长度为 <span class="math inline">\(n\)</span> 的 <span
class="math inline">\(01\)</span> 串，有 <span
class="math inline">\(m\)</span> 个位置是 <span
class="math inline">\(1\)</span> ，最长的 <span
class="math inline">\(1\)</span> 的连续段长度是 <span
class="math inline">\(k\)</span> ，求方案数。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(0 \le n, m, k \le 10^5\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p><img src="https://z1.ax1x.com/2023/10/11/piSCgJJ.png" /> <img
src="https://z1.ax1x.com/2023/10/11/piSCci4.png" /> <img
src="https://z1.ax1x.com/2023/10/11/piSCyoF.png" /></p>
<h2 id="参考代码">参考代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Mod = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> fac[MAXN], invf[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			res = res * x % Mod;</span><br><span class="line">		&#125;</span><br><span class="line">		x = x * x % Mod;</span><br><span class="line">		y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ksm</span>(x, Mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> lim)</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lim; i++) &#123;</span><br><span class="line">		fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">	&#125;</span><br><span class="line">	invf[lim] = <span class="built_in">inv</span>(fac[lim]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = lim - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		invf[i] = <span class="number">1ll</span> * invf[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % Mod; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1ll</span> * fac[x] * invf[y] % Mod * invf[x - y] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">C</span>(x + y - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> coef = (i &amp; <span class="number">1</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> add = <span class="number">1ll</span> * <span class="built_in">C</span>(n - m + <span class="number">1</span>, i) * <span class="built_in">calc</span>(m - i * (k + <span class="number">1</span>), n - m + <span class="number">1</span>) % Mod;</span><br><span class="line">		<span class="keyword">if</span> (coef == <span class="number">-1</span>) &#123;</span><br><span class="line">			add = Mod - add;</span><br><span class="line">		&#125;</span><br><span class="line">		res = (res + add) % Mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(MAXN - <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> n, m, k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> ans = (<span class="built_in">solve</span>(n, m, k) - <span class="built_in">solve</span>(n, m, k - <span class="number">1</span>) + Mod) % Mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>XCPC解题报告</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>【题解】ICPC2022济南站 A - Tower</title>
    <url>/2023/10/07/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91ICPC2022%E6%B5%8E%E5%8D%97%E7%AB%99%20A%20-%20Tower/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://codeforces.com/gym/104076/problem/A">https://codeforces.com/gym/104076/problem/A</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span
class="math inline">\(\{ a_n\}\)</span> ，移去其中长度为 <span
class="math inline">\(m\)</span>
的子序列，对于剩下的元素能进行如下三种操作（无顺序和次数限制）：</p>
<ul>
<li>加 <span class="math inline">\(1\)</span></li>
<li>减 <span class="math inline">\(1\)</span></li>
<li>除以 <span class="math inline">\(2\)</span> 并向下取整</li>
</ul>
<p>问最少进行多少次操作能把这些数变相同。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(1\le n \le 500 , 0 \le m &lt; n, 1\le
a_i \le 10^{9}\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p><img src="https://z1.ax1x.com/2023/10/07/pPjdQYQ.png" /></p>
<p><img src="https://z1.ax1x.com/2023/10/07/pPjd8ln.png" /></p>
<h2 id="参考代码">参考代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fstep</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= cur) &#123;</span><br><span class="line">		<span class="keyword">return</span> x - cur;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> s = <span class="number">0</span>, lstc = cur;</span><br><span class="line">	<span class="keyword">while</span> (cur &gt; x) &#123;</span><br><span class="line">		lstc = cur;</span><br><span class="line">		cur &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">assert</span>(cur != <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> res = <span class="built_in">min</span>(s + (x - cur), (s - <span class="number">1</span>) + (lstc - x));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> step = <span class="built_in">fstep</span>(x, a[i]);</span><br><span class="line">		vec.<span class="built_in">push_back</span>(step);</span><br><span class="line">	&#125;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">		res += vec[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ll ans = INF;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x = a[i];</span><br><span class="line">		<span class="keyword">while</span> (x) &#123;</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, <span class="built_in">calc</span>(x));</span><br><span class="line">			x &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>XCPC解题报告</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>【杂题】7,8月杂题选做</title>
    <url>/2023/07/18/%E3%80%90%E6%9D%82%E9%A2%98%E3%80%917,8%E6%9C%88%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A/</url>
    <content><![CDATA[<h1 id="图论相关">图论相关</h1>
<h2 id="题目来源">题目来源</h2>
<p><a
href="https://atcoder.jp/contests/abc308/tasks/abc308_h">ABC308Ex</a></p>
<h2 id="题意">题意</h2>
<p>给定一张 <span class="math inline">\(n\)</span> 个点 <span
class="math inline">\(m\)</span>
条边的无向带权图，找到图中一个权值最小的 <span
class="math inline">\(\text{Q}\)</span> 。</p>
<p><span class="math inline">\(\text{Q}\)</span>
定义为一个环带上一条与这个环相连且不在环上的边。</p>
<p><span class="math inline">\(4\le n \le 300 , 4\le m \le
\frac{n(n-1)}{2}\)</span> 。</p>
<h2 id="思路">思路</h2>
<p>考虑枚举每一条边作为 <span class="math inline">\(\text{Q}\)</span>
的尾巴，然后把这条边删去，从这条边的一个端点跑一个单源最短路。然后再枚举两个点，能够轻松找到不经过这条边的一个最小环。</p>
<p>这样枚举尾巴的时间复杂度为 <span
class="math inline">\(O(n^2)\)</span> ，找最小环的时间复杂度为 <span
class="math inline">\(O(n^2)\)</span> ，总时间复杂度为 <span
class="math inline">\(O(n^4)\)</span> ，这是难以接受的。</p>
<p>考虑到一个环会占用一个点相连的两条边，最劣情况下尾巴也是第三小的边，所以我们第一步不需要枚举所有的边作为尾巴，只需要枚举每个点相连的前三小的边做尾巴即可。这样枚举尾巴的时间复杂度降为
<span class="math inline">\(O(n)\)</span> ，总时间复杂度降为 <span
class="math inline">\(O(n^3)\)</span> 。</p>
<span id="more"></span>
<h1 id="动态规划">动态规划</h1>
<h2 id="题目来源-1">题目来源</h2>
<p><a
href="https://codeforces.com/problemset/problem/626/F">CF626F</a></p>
<h2 id="题意-1">题意</h2>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的数列 <span
class="math inline">\(a\)</span> ，把 <span
class="math inline">\(a\)</span>
分成任意组，每组的<strong>不和谐度</strong>定义为该组内元组的最大值与最小值之差，求所有<strong>不和谐度</strong>之和不超过
<span class="math inline">\(m\)</span> 的分组方案数，对 <span
class="math inline">\(10^9 + 7\)</span> 取模。</p>
<p><span class="math inline">\(1 \le n \le 200 , 0 \le m \le 10^3 , 1
\le a_i \le 500\)</span> 。</p>
<h2 id="思路-1">思路</h2>
<p>由于<strong>不和谐度</strong>是最大值与最小值的差，乱找不好找，考虑对数列
<span class="math inline">\(a\)</span>
从小到大进行排序，然后依次考虑每个数的分组情况。</p>
<p>考虑设 <span class="math inline">\(f_{i,j,k}\)</span> 为选了前 <span
class="math inline">\(i\)</span> 个位置，有 <span
class="math inline">\(j\)</span> 个没有结束的组，当前选的总不和谐度为
<span class="math inline">\(k\)</span> 的方案数。</p>
<p>考虑若有一个组选了 <span class="math inline">\(a_{p_1} , a_{p_2} ,
\cdots, a_{p_n}\)</span> 这些元素，且 <span class="math inline">\(p_1
&lt; p_2 &lt; \cdots &lt; p_n\)</span> ，则不和谐度为 <span
class="math inline">\(a_{p_n} - a_{p_1}\)</span> 。</p>
<p>考虑到 <span class="math inline">\(a_{p_n} - a_{p_1} = (a_{p_n} -
a_{p_{n-1}}) + (a_{p_{n-1}} - a_{p_{n-2}}) + \cdots + (a_{p_2} -
a_{p_1})\)</span> ，所以每次向之前的某一组中加入 <span
class="math inline">\(a_{i + 1}\)</span> 这个元素时，所有的组都会被增加
<span class="math inline">\(a_{i + 1} - a_{i}\)</span>
的不和谐度，利用这个可以找到转移时 <span
class="math inline">\(k\)</span> 的增量。</p>
<p>再考虑转移的几种情况：</p>
<ul>
<li><p>当前点单独成组：<span class="math inline">\(f_{i + 1 , j , k + j
\times (a_{i + 1} - a_i)} \leftarrow f_{i,j,k}\)</span> 。</p></li>
<li><p>当前点加入一个组中，即不作为最大值，也不作为最小值：<span
class="math inline">\(f_{i + 1, j, k + j \times (a_{i+1} - a_{i})}
\leftarrow f_{i, j, k}\)</span> 。</p></li>
<li><p>当前点新开一个组，且作为最小值：<span class="math inline">\(f_{i
+ 1, j + 1 , k + j \times(a_{i + 1} - a_{i})} \leftarrow
f_{i,j,k}\)</span> 。</p></li>
<li><p>当前点结束一个组，且作为最大值：<span class="math inline">\(f_{i
+ 1, j - 1, k + j \times (a_{i+1}-a_{i})} \leftarrow f_{i,j,k}\)</span>
。</p></li>
</ul>
<p>复杂度可以做到 <span class="math inline">\(O(n^2 m)\)</span> 。</p>
<h2 id="题目来源-2">题目来源</h2>
<p><a
href="https://acjudge.com/d/algorithmbasics/p/773">acjudge#773</a></p>
<h2 id="题意-2">题意</h2>
<p>有 <span class="math inline">\(n\)</span> 个物品和四个盒子 <span
class="math inline">\(A,B,C,D\)</span> ，每个物品都有一个重量 <span
class="math inline">\(w_i\)</span>
，你需要将每个物品放入一个盒子中。</p>
<p>给定 <span class="math inline">\(k_1,k_2,k_3,k_4\)</span> ，设 <span
class="math inline">\(|X|\)</span> 表示 <span
class="math inline">\(X\)</span>
盒子内物品的总重，一个合法的装盒方案最终应当满足如下的条件：</p>
<p><span class="math display">\[
|A|+|B|\le k_1
\]</span></p>
<p><span class="math display">\[
|C|+|D|\le k_2
\]</span></p>
<p><span class="math display">\[
|A|+|C|\le k_3
\]</span></p>
<p><span class="math display">\[
|B|+|D|\le k_4
\]</span></p>
<p>求有多少种合法的装盒方案，答案对 <span
class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(1\le n \le 100 , 1 \le k_i \le
1000\)</span> 。</p>
<h2 id="思路-2">思路</h2>
<p>脑筋慢转弯题（bushi</p>
<p>最直接的思路就是一个四维的背包 <span
class="math inline">\(\text{dp}\)</span> ，设 <span
class="math inline">\(f_{i,a,b,c,d}\)</span> 表示前 <span
class="math inline">\(i\)</span> 件物品，<span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 总共放了 <span
class="math inline">\(a\)</span> ，<span
class="math inline">\(C\)</span> 和 <span
class="math inline">\(D\)</span> 总共放了 <span
class="math inline">\(b\)</span> ，<span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(C\)</span> 总共放了 <span
class="math inline">\(c\)</span> ， <span
class="math inline">\(B\)</span> 和 <span
class="math inline">\(D\)</span> 总共放了 <span
class="math inline">\(d\)</span>
，满足以上限制的总方案数。转移就考虑当前物品放入哪一个箱子。</p>
<p>发现四个盒子两两组合总共有 <span class="math inline">\(6\)</span>
种，但题目中只限制了 <span class="math inline">\(4\)</span>
种，于是找一下关系，不难发现前两个式子加起来是 <span
class="math inline">\(|A| + |B| + |C| + |D|\)</span>
，后两个式子加起来也是 <span class="math inline">\(|A| + |B| + |C| +
|D|\)</span> 。</p>
<p>设 <span class="math inline">\(w_i\)</span> 的前缀和是 <span
class="math inline">\(sum_i\)</span> ，那么到第 <span
class="math inline">\(i\)</span>
个位置，由于每个物品一定会被放入四个盒子其中之一，所以 <span
class="math inline">\(a + c = |A| + |B| + |C| + |D| = sum_i\)</span>
，<span class="math inline">\(b + d = |A| + |B| + |C| + |D| =
sum_i\)</span> ，所以我们找到了 <span class="math inline">\(a,c\)</span>
之间和 <span class="math inline">\(b,d\)</span>
之间的关系，这样可以压掉两维，时间复杂度变成了 <span
class="math inline">\(O(n k ^2)\)</span> 。</p>
]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>QwQ</tag>
      </tags>
  </entry>
  <entry>
    <title>【索引】AtCoder解题报告</title>
    <url>/2023/10/08/%E3%80%90%E7%B4%A2%E5%BC%95%E3%80%91AtCoder%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h2 id="atcoder-beginner-contest">AtCoder Beginner Contest</h2>
<p><strong>ABC171</strong></p>
<p><a href="https://tle-automat.top/2023/12/15/ABC171F/">F -
Strivore</a></p>
<p><strong>ABC335</strong></p>
<p><a href="https://tle-automat.top/2024/01/17/ABC335G/">G - Discrete
Logarithm Problems</a></p>
<h2 id="atcoder-regular-contest">AtCoder Regular Contest</h2>
<p><strong>ARC167</strong></p>
<p><a
href="http://www.tle-automat.top/2023/10/20/ARC167%20D.%20Good%20Permutation/">D
- Good Permutation</a></p>
<h2 id="atcoder-grand-contest">AtCoder Grand Contest</h2>
<span id="more"></span>
]]></content>
      <categories>
        <category>AtCoder解题报告</category>
      </categories>
      <tags>
        <tag>QwQ</tag>
      </tags>
  </entry>
  <entry>
    <title>【索引】Codeforces解题报告</title>
    <url>/2023/10/08/%E3%80%90%E7%B4%A2%E5%BC%95%E3%80%91Codeforces%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h2 id="codeforces-round">Codeforces Round</h2>
<p><strong>Round 913 div.3</strong></p>
<p><a href="https://tle-automat.top/2023/12/09/CF1907G/">CF1907G</a></p>
<span id="more"></span>
<h2 id="educational-codeforces-round">Educational Codeforces Round</h2>
<h2 id="other-round">Other Round</h2>
]]></content>
      <categories>
        <category>Codeforces解题报告</category>
      </categories>
      <tags>
        <tag>QwQ</tag>
      </tags>
  </entry>
  <entry>
    <title>【索引】XCPC解题报告</title>
    <url>/2023/10/07/%E3%80%90%E7%B4%A2%E5%BC%95%E3%80%91XCPC%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="icpc">ICPC</h1>
<h2 id="season-2021---2022">Season 2021 - 2022</h2>
<p>ICPC2021 沈阳站</p>
<p><a
href="http://www.tle-automat.top/2023/10/19/ICPC2021沈阳站%20L.%20Perfect%20Matchings/">L.
Perfect Matchings</a></p>
<p><a
href="http://www.tle-automat.top/2023/10/15/ICPC2021沈阳站%20M.%20String%20Problem/">M.
String Problem</a></p>
<h2 id="season-2022---2023">Season 2022 - 2023</h2>
<p>ICPC2022 济南站</p>
<p><a
href="https://tle-automat.top/2023/10/07/ICPC2022%E6%B5%8E%E5%8D%97%E7%AB%99%20A.%20Tower/">A.
Tower</a></p>
<h1 id="ccpc">CCPC</h1>
<h2 id="season-2021---2022-1">Season 2021 - 2022</h2>
<p>CCPC2021 威海站</p>
<p><a
href="http://www.tle-automat.top/2023/10/11/CCPC2021威海站%20M.%20810975/">M.
810975</a></p>
<span id="more"></span>
]]></content>
      <categories>
        <category>XCPC解题报告</category>
      </categories>
      <tags>
        <tag>QwQ</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希技巧小结</title>
    <url>/2023/11/15/%E5%93%88%E5%B8%8C%E6%8A%80%E5%B7%A7%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流知识点汇总</title>
    <url>/2023/10/12/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>【索引】Re零系列学习笔记</title>
    <url>/2023/10/08/Re%E9%9B%B6%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>索引</category>
      </categories>
      <tags>
        <tag>QwQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的博弈论（博弈论学习笔记索引）</title>
    <url>/2023/10/08/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>索引</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的多项式（多项式学习笔记索引）</title>
    <url>/2023/10/08/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>索引</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的字符串算法（字符串算法学习笔记索引）</title>
    <url>/2023/10/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>索引</category>
      </categories>
      <tags>
        <tag>字符串算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的生成函数（组合数学学习笔记索引）</title>
    <url>/2023/10/08/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>索引</category>
      </categories>
      <tags>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的数论（数论学习笔记索引）</title>
    <url>/2023/10/08/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>索引</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的计算几何（计算几何学习笔记索引）</title>
    <url>/2023/10/08/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>索引</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
</search>
