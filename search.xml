<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>目录</title>
    <url>/2023/10/08/%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>0</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC2023桂林站【游记】</title>
    <url>/2023/11/08/CCPC2023%E6%A1%82%E6%9E%97%E7%AB%99%E3%80%90%E6%B8%B8%E8%AE%B0%E3%80%91/</url>
    <content><![CDATA[<h1 id="day--1">Day -1</h1>
<p>大学第一场 xcpc ，有些小激动。</p>
<p>经历了一天的颠簸，晚上终于坐飞机到桂林了，刷新了从小到大到达过的最南边和最西边的记录。</p>
<p>不愧于“桂林山水甲天下”的美誉，桂林的喀斯特地貌几乎随处可见，小城周围环绕的山地总能给人一种与世隔绝的安宁。</p>
<h1 id="day-0">Day 0</h1>
<p>早上领到了桂林站主办方准备的桂林特产。</p>
<p>中午吃到了桂林本地的螺狮粉（其实这是我第一次吃螺狮粉），我也不知道这是不是正宗的螺狮粉，反正跟臭豆腐差不多，制作过程中闻起来挺臭，但吃起来一点也不臭。</p>
<p>下午热身赛。</p>
<p>到了桂林电子科技大学之后，感觉东秦直接被吊打得体无完肤/ll。虽然桂电有地理位置的优势，四面环山环境优美，而且地还巨大，这些东秦没法比，但是为啥东秦的硬件被吊锤成这样，经费呢？？？？？？？？</p>
<p>进场之后，由于我第一次使用 ubuntu 系统，并且没怎么用过 vscode 和
code_blocks，更致命的是最有经验的大三队友还没到，另外一个队友也没用过，所以我们研究编译研究了好久，结果热身赛快结束的时候被同校的另外一支队伍告知是文件夹建在了中文目录下导致编译不了/tuu。</p>
<p>最后热身赛只惨淡地过了一道题。</p>
<h1 id="day-1">Day 1</h1>
<p>开场十分紧张。</p>
<p>队友先看到了签到题 G ，结果上来 WA
了一发，更慌了，还好马上发现错误之后过了，然后我看了一眼 M
题不是很会，过了一会看榜发现 M 好像是个签到题，又回来想
M，脑子一热想错了一个条件，反复跟队友确认之后发现自己漏了一个条件想假了，又讨论了一会发现是个二分加最大子段和，然后带着慌张的情绪写写写，写完又出了好几个bug，不过还好调过样例之后就过了。</p>
<p>然后此时队友说 B 有思路，提议看 B
题，然后觉得队友想法很对，但是细节上有些乱，然后就写写写，发现有一种很重要的情况没有判断，然后开始改改改，中间浪费了很长时间，但样例还是一直过不去，心态已经开始炸了。</p>
<p>大概 2.5h 左右，B题实在调不出来了，选择开 K
题，很快发现是一个将数据范围分成两部分分别暴力，但是不管怎么写样例都能过，交上去还一直炸裂，就这样磨了
1
个多小时，心态已经被磨到不行了，最后队友发现是置换进行运算时不能交换，我做置换运算的时候做反了/ll。</p>
<p>此时我们在铜牌垫底区，队友继续在调 B
题，但我当时心态已经炸裂到不知道该干啥了，于是去跟榜看 I
题。我努力试图让自己冷静下来，经过不久的思考，我把 I
题的题意转化成一堆询问，每次询问求区间颜色数，这是一个非常经典的问题，但此时离比赛结束还有
45min，我不知所措根本没有时间静下心来（其实也怪我菜，心理素质还差），居然没想到可以离线树状数组做，然后队友说可以主席树（但他在调
B
，显然没有时间过来帮我写），我一想也是，但已经完全忘记怎么写了，于是我就一直打摆打到比赛结束。</p>
<p>最后 3 题遗憾打铁，属于是自费出来旅游了。（差 5 名 Cu）/大哭</p>
<p>真是应了那句话“期望越大，失望越大”。</p>
<p>究其原因，大概又以下几点：</p>
<ul>
<li><p><strong>队伍磨合差</strong></p>
<p>其实按照实力来讲，我们队应该至少能过 5
题，但赛前除了两场挂一场的预选赛，队伍从来没有在一起打过别的比赛，队内化学反应很差，根本磨合不起来。</p></li>
<li><p><strong>自己水平不够</strong></p>
<p>自己疏于算法竞赛一年多，本来就是个弱省省一水平，现在更菜了</p></li>
<li><p><strong>怯场+心态不平稳</strong></p>
<p>第一次线下赛怯场导致无法将自己实力全部发挥</p></li>
</ul>
<p>还是要多 vp CF Edu 和 ARC
的比赛提升个人的思维和代码水平，并且通过和队友一起 vp xcpc
真题来提升队伍磨合。</p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title>XCPC解题报告索引</title>
    <url>/2023/10/07/XCPC%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="icpc">ICPC</h1>
<h2 id="season-2021---2022">Season 2021 - 2022</h2>
<p>ICPC2021 沈阳站</p>
<p><a
href="http://www.tle-automat.top/2023/10/19/ICPC2021沈阳站%20L.%20Perfect%20Matchings/">L.
Perfect Matchings</a></p>
<p><a
href="http://www.tle-automat.top/2023/10/15/ICPC2021沈阳站%20M.%20String%20Problem/">M.
String Problem</a></p>
<h2 id="season-2022---2023">Season 2022 - 2023</h2>
<p>ICPC2022 济南站</p>
<p><a
href="https://tle-automat.top/2023/10/07/ICPC2022%E6%B5%8E%E5%8D%97%E7%AB%99%20A.%20Tower/">A.
Tower</a></p>
<h1 id="ccpc">CCPC</h1>
<h2 id="season-2021---2022-1">Season 2021 - 2022</h2>
<p>CCPC2021 威海站</p>
<p><a
href="http://www.tle-automat.top/2023/10/11/CCPC2021威海站%20M.%20810975/">M.
810975</a></p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>XCPC解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title>AtCoder解题报告索引</title>
    <url>/2023/10/08/AtCoder%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="atcoder-beginner-contest">AtCoder Beginner Contest</h1>
<h1 id="atcoder-regular-contest">AtCoder Regular Contest</h1>
<h2 id="arc167">ARC167</h2>
<p><a
href="http://www.tle-automat.top/2023/10/20/ARC167%20D.%20Good%20Permutation/">D.
Good Permutation</a></p>
<h1 id="atcoder-grand-contest">AtCoder Grand Contest</h1>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>AtCoder解题报告</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces解题报告索引</title>
    <url>/2023/10/08/Codeforces%20%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="codeforces-round">Codeforces Round</h1>
<span id="more"></span>
<h1 id="educational-codeforces-round">Educational Codeforces Round</h1>
<h1 id="other-round">Other Round</h1>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>Codeforces解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title>Re零系列学习笔记索引</title>
    <url>/2023/10/08/Re%E9%9B%B6%E7%B3%BB%E5%88%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的树论（树上算法学习笔记索引）</title>
    <url>/2023/10/26/%E6%A0%91%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>树论</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的动态规划（动态规划学习笔记索引）</title>
    <url>/2023/10/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>动态规划(DP)</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的图论（图论学习笔记索引）</title>
    <url>/2023/10/08/%E5%9B%BE%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的多项式（多项式学习笔记索引）</title>
    <url>/2023/10/08/%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的博弈论（博弈论学习笔记索引）</title>
    <url>/2023/10/08/%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的字符串算法（字符串算法学习笔记索引）</title>
    <url>/2023/10/08/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>字符串算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的数据结构（数据结构学习笔记索引）</title>
    <url>/2023/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的数论（数论学习笔记索引）</title>
    <url>/2023/10/08/%E6%95%B0%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的线性代数（线性代数学习笔记索引）</title>
    <url>/2023/10/08/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的组合数学（组合数学学习笔记索引）</title>
    <url>/2023/10/08/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Re:从零开始的计算几何（计算几何学习笔记索引）</title>
    <url>/2023/10/08/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>索引</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>网络流学习笔记</title>
    <url>/2023/10/12/%E7%BD%91%E7%BB%9C%E6%B5%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>咕。咕。咕。</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title>ARC167 D. Good Permutation</title>
    <url>/2023/10/20/ARC167%20D.%20Good%20Permutation/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://atcoder.jp/contests/arc167/tasks/arc167_d">https://atcoder.jp/contests/arc167/tasks/arc167_d</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定一个 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 的排列 <span
class="math inline">\(P\)</span> 。</p>
<p>定义一个排列 <span class="math inline">\(Q\)</span>
为好排列当且仅当对于任意整数 <span class="math inline">\(1\le x \le
n\)</span> ，通过若干次赋值（可以为 <span
class="math inline">\(0\)</span> 次） <span class="math inline">\(x
\leftarrow Q_x\)</span> ，最终能够使得 <span
class="math inline">\(x\)</span> 变成 <span
class="math inline">\(1\)</span> 。</p>
<p>现在可以进行若干次操作，每次可以交换 <span
class="math inline">\(P\)</span> 的任意两个不同的位置。</p>
<p>假设最少进行 <span class="math inline">\(m\)</span> 次操作使得 <span
class="math inline">\(P\)</span> 成为一个好排列，求进行 <span
class="math inline">\(m\)</span> 操作之后 <span
class="math inline">\(P\)</span> 能够成为的字典序最小的好排列。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(\sum n \le 2 \times 10 ^
{5}\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<h2 id="参考代码">参考代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; suf[i];</span><br><span class="line">		pre[suf[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	set&lt;<span class="type">int</span>&gt; circle, oth;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		oth.<span class="built_in">insert</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	oth.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (suf[x] != <span class="number">1</span>) &#123;</span><br><span class="line">		x = suf[x];</span><br><span class="line">		oth.<span class="built_in">erase</span>(x);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">assert</span>(oth.<span class="built_in">find</span>(i) == oth.<span class="built_in">end</span>());</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (oth.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> mnx = *oth.<span class="built_in">begin</span>();</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		printf(&quot;i = %d, mnx = %d\n&quot;, i, mnx);</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (mnx &gt; suf[i] &amp;&amp; i + <span class="built_in">SZ</span>(oth) &lt; n) &#123;</span><br><span class="line"><span class="comment">//			printf(&quot;continue pos : %d\n&quot;, i);</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> cur = mnx;</span><br><span class="line">		oth.<span class="built_in">erase</span>(cur);</span><br><span class="line">		<span class="keyword">while</span> (suf[cur] != mnx) &#123;</span><br><span class="line">			cur = suf[cur];</span><br><span class="line">			oth.<span class="built_in">erase</span>(cur);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		suf[pre[mnx]] = suf[i];</span><br><span class="line">		pre[suf[i]] = pre[mnx];</span><br><span class="line">		</span><br><span class="line">		suf[i] = mnx;</span><br><span class="line">		pre[mnx] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">	x = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		ans[x] = suf[x];</span><br><span class="line">		x = suf[x];</span><br><span class="line">	&#125; <span class="keyword">while</span> (x != <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]); </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--) &#123;</span><br><span class="line">		<span class="built_in">solve</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>AtCoder解题报告</tag>
        <tag>图论</tag>
        <tag>环</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC2021沈阳站 L. Perfect Matchings</title>
    <url>/2023/10/19/ICPC2021%E6%B2%88%E9%98%B3%E7%AB%99%20L.%20Perfect%20Matchings/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://codeforces.com/gym/103427/problem/L">https://codeforces.com/gym/103427/problem/L</a></p>
<h2 id="题目大意">题目大意</h2>
<p>有一个 <span class="math inline">\(2n\)</span>
个点的完全图，给出这个完全图的一颗生成树，从完全图上删去树上的边，求剩下的图的完美匹配的方案数。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(2 \le n \le 2000\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p><img src="https://z1.ax1x.com/2023/10/19/piiGp7t.png" /> <img
src="https://z1.ax1x.com/2023/10/19/piiGS0I.png" /></p>
<h2 id="参考代码">参考代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">	sz[u] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">dfs</span>(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	dp[u][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> v : G[u]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (v == fa) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(tmp, dp[u], <span class="built_in">sizeof</span>(dp[u]));</span><br><span class="line">		<span class="built_in">memset</span>(dp[u], <span class="number">0</span>, <span class="built_in">sizeof</span>(dp[u]));</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= sz[u] / <span class="number">2</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= sz[v] / <span class="number">2</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!dp[v][j][<span class="number">0</span>]) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			</span><br><span class="line">				<span class="keyword">if</span> (tmp[i][<span class="number">0</span>]) &#123;</span><br><span class="line">					<span class="built_in">add_mod</span>(dp[u][i + j][<span class="number">0</span>], <span class="number">1ll</span> * tmp[i][<span class="number">0</span>] * dp[v][j][<span class="number">0</span>] % Mod);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (tmp[i][<span class="number">0</span>]) &#123;</span><br><span class="line">					<span class="built_in">add_mod</span>(dp[u][i + j + <span class="number">1</span>][<span class="number">1</span>], <span class="number">1ll</span> * tmp[i][<span class="number">0</span>] * dp[v][j][<span class="number">0</span>] % Mod);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (tmp[i][<span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="built_in">add_mod</span>(dp[u][i + j][<span class="number">1</span>], <span class="number">1ll</span> * tmp[i][<span class="number">1</span>] * dp[v][j][<span class="number">0</span>] % Mod);</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= sz[v] / <span class="number">2</span>; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!dp[v][j][<span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="keyword">if</span> (tmp[i][<span class="number">1</span>]) &#123;</span><br><span class="line">					<span class="built_in">add_mod</span>(dp[u][i + j][<span class="number">1</span>], <span class="number">1ll</span> * tmp[i][<span class="number">1</span>] * dp[v][j][<span class="number">1</span>] % Mod);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (tmp[i][<span class="number">0</span>]) &#123;</span><br><span class="line">					<span class="built_in">add_mod</span>(dp[u][i + j][<span class="number">0</span>], <span class="number">1ll</span> * tmp[i][<span class="number">0</span>] * dp[v][j][<span class="number">1</span>] % Mod);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sz[u] += sz[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> u, v;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">		G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">		fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">	&#125; </span><br><span class="line">	invf[<span class="number">2</span> * n] = <span class="built_in">inv</span>(fac[<span class="number">2</span> * n]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span> * n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		invf[i] = <span class="number">1ll</span> * invf[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % Mod;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">2</span> * n; i += <span class="number">2</span>) &#123;</span><br><span class="line">		f[i] = <span class="number">1ll</span> * fac[i] * <span class="built_in">inv</span>(<span class="built_in">ksm</span>(<span class="number">2ll</span>, i / <span class="number">2</span>)) % Mod * invf[i / <span class="number">2</span>] % Mod;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		g[i] = <span class="number">1ll</span> * (dp[<span class="number">1</span>][i][<span class="number">0</span>] + dp[<span class="number">1</span>][i][<span class="number">1</span>]) * f[<span class="number">2</span> * (n - i)] % Mod;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> ans = f[<span class="number">2</span> * n];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> add = g[i];</span><br><span class="line">		<span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			add = Mod - add;</span><br><span class="line">		&#125;</span><br><span class="line">		ans = (ans + add) % Mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>XCPC解题报告</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
        <tag>动态规划</tag>
        <tag>树形背包</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC2021沈阳站 M. String Problem</title>
    <url>/2023/10/15/ICPC2021%E6%B2%88%E9%98%B3%E7%AB%99%20M.%20String%20Problem/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://codeforces.com/gym/103427/problem/M">https://codeforces.com/gym/103427/problem/M</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定小写字母构成的字符串 <span class="math inline">\(S\)</span>
，对于 <span class="math inline">\(S\)</span>
的每个前缀，求该前缀的所有子串中字典序最大且出现位置最靠左的子串的左右端点。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(1 \le |S| \le 10^6\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p><img src="https://z1.ax1x.com/2023/10/15/pi9XYUH.png" /> <img
src="https://z1.ax1x.com/2023/10/15/pi9X3DO.png" /> <img
src="https://z1.ax1x.com/2023/10/15/pi9XJVe.png" /> <img
src="https://z1.ax1x.com/2023/10/15/pi9X8bD.png" /></p>
<h2 id="参考代码">参考代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span>+<span class="number">10</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> SA :: sa;</span><br><span class="line"><span class="keyword">using</span> SA :: rk;</span><br><span class="line"><span class="keyword">using</span> SA :: height;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"><span class="type">int</span> st[MAXN][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> h[MAXN], pos[MAXN];</span><br><span class="line"><span class="type">int</span> lg2[MAXN];</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; S;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> s = lg2[r - l + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">min</span>(st[l][s], st[r - (<span class="number">1</span> &lt;&lt; s) + <span class="number">1</span>][s]);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qlmax</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> it = S.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">	<span class="keyword">if</span> (it == S.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; </span><br><span class="line">		<span class="keyword">return</span> *(--it);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">	n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">	SA::<span class="built_in">init</span>(s, n);</span><br><span class="line">	</span><br><span class="line">	lg2[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		lg2[i] = lg2[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		st[i][<span class="number">0</span>] = height[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">20</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">			st[i][j] = <span class="built_in">min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	h[rk[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">	S.<span class="built_in">insert</span>(rk[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> r = rk[i];</span><br><span class="line">		<span class="type">int</span> l = <span class="built_in">qlmax</span>(r);</span><br><span class="line">		<span class="keyword">if</span> (l == <span class="number">-1</span>) &#123;</span><br><span class="line">			h[r] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			h[r] = <span class="built_in">query</span>(l + <span class="number">1</span>, r);</span><br><span class="line">		&#125;</span><br><span class="line">		S.<span class="built_in">insert</span>(r);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n, r = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">		<span class="type">int</span> x = sa[i] + h[i];</span><br><span class="line">		<span class="keyword">while</span> (r &gt;= x) &#123;</span><br><span class="line">			pos[r] = sa[i];</span><br><span class="line">			r--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, pos[i], i);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>XCPC解题报告</tag>
        <tag>字符串算法</tag>
        <tag>后缀排序</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title>CCPC2021威海站 M. 810975</title>
    <url>/2023/10/11/CCPC2021%E5%A8%81%E6%B5%B7%E7%AB%99%20M.%20810975/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://codeforces.com/gym/103428/problem/M">https://codeforces.com/gym/103428/problem/M</a></p>
<h2 id="题目大意">题目大意</h2>
<p>一个长度为 <span class="math inline">\(n\)</span> 的 <span
class="math inline">\(01\)</span> 串，有 <span
class="math inline">\(m\)</span> 个位置是 <span
class="math inline">\(1\)</span> ，最长的 <span
class="math inline">\(1\)</span> 的连续段长度是 <span
class="math inline">\(k\)</span> ，求方案数。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(0 \le n, m, k \le 10^5\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p><img src="https://z1.ax1x.com/2023/10/11/piSCgJJ.png" /> <img
src="https://z1.ax1x.com/2023/10/11/piSCci4.png" /> <img
src="https://z1.ax1x.com/2023/10/11/piSCyoF.png" /></p>
<h2 id="参考代码">参考代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Mod = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> fac[MAXN], invf[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">ksm</span><span class="params">(ll x, ll y)</span> </span>&#123;</span><br><span class="line">	ll res = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (y) &#123;</span><br><span class="line">		<span class="keyword">if</span> (y &amp; <span class="number">1</span>) &#123;</span><br><span class="line">			res = res * x % Mod;</span><br><span class="line">		&#125;</span><br><span class="line">		x = x * x % Mod;</span><br><span class="line">		y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">ksm</span>(x, Mod - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> lim)</span> </span>&#123;</span><br><span class="line">	fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lim; i++) &#123;</span><br><span class="line">		fac[i] = <span class="number">1ll</span> * fac[i - <span class="number">1</span>] * i % Mod;</span><br><span class="line">	&#125;</span><br><span class="line">	invf[lim] = <span class="built_in">inv</span>(fac[lim]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = lim - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		invf[i] = <span class="number">1ll</span> * invf[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % Mod; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1ll</span> * fac[x] * invf[y] % Mod * invf[x - y] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">C</span>(x + y - <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> coef = (i &amp; <span class="number">1</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">		<span class="type">int</span> add = <span class="number">1ll</span> * <span class="built_in">C</span>(n - m + <span class="number">1</span>, i) * <span class="built_in">calc</span>(m - i * (k + <span class="number">1</span>), n - m + <span class="number">1</span>) % Mod;</span><br><span class="line">		<span class="keyword">if</span> (coef == <span class="number">-1</span>) &#123;</span><br><span class="line">			add = Mod - add;</span><br><span class="line">		&#125;</span><br><span class="line">		res = (res + add) % Mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">init</span>(MAXN - <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> n, m, k;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> ans = (<span class="built_in">solve</span>(n, m, k) - <span class="built_in">solve</span>(n, m, k - <span class="number">1</span>) + Mod) % Mod;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>XCPC解题报告</tag>
        <tag>组合数学</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title>ICPC2022济南站 A. Tower</title>
    <url>/2023/10/07/ICPC2022%E6%B5%8E%E5%8D%97%E7%AB%99%20A.%20Tower/</url>
    <content><![CDATA[<h2 id="题目链接">题目链接</h2>
<p><a
href="https://codeforces.com/gym/104076/problem/A">https://codeforces.com/gym/104076/problem/A</a></p>
<h2 id="题目大意">题目大意</h2>
<p>给定长度为 <span class="math inline">\(n\)</span> 的序列 <span
class="math inline">\(\{ a_n\}\)</span> ，移去其中长度为 <span
class="math inline">\(m\)</span>
的子序列，对于剩下的元素能进行如下三种操作（无顺序和次数限制）：</p>
<ul>
<li>加 <span class="math inline">\(1\)</span></li>
<li>减 <span class="math inline">\(1\)</span></li>
<li>除以 <span class="math inline">\(2\)</span> 并向下取整</li>
</ul>
<p>问最少进行多少次操作能把这些数变相同。</p>
<h2 id="数据范围">数据范围</h2>
<ul>
<li><span class="math inline">\(1\le n \le 500 , 0 \le m &lt; n, 1\le
a_i \le 10^{9}\)</span></li>
</ul>
<span id="more"></span>
<h2 id="解题思路">解题思路</h2>
<p><img src="https://z1.ax1x.com/2023/10/07/pPjdQYQ.png" /></p>
<p><img src="https://z1.ax1x.com/2023/10/07/pPjd8ln.png" /></p>
<h2 id="参考代码">参考代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e2</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fstep</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> cur)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt;= cur) &#123;</span><br><span class="line">		<span class="keyword">return</span> x - cur;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> s = <span class="number">0</span>, lstc = cur;</span><br><span class="line">	<span class="keyword">while</span> (cur &gt; x) &#123;</span><br><span class="line">		lstc = cur;</span><br><span class="line">		cur &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">		s++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">assert</span>(cur != <span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> res = <span class="built_in">min</span>(s + (x - cur), (s - <span class="number">1</span>) + (lstc - x));</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> step = <span class="built_in">fstep</span>(x, a[i]);</span><br><span class="line">		vec.<span class="built_in">push_back</span>(step);</span><br><span class="line">	&#125;</span><br><span class="line">	ll res = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - m; i++) &#123;</span><br><span class="line">		res += vec[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		cin &gt;&gt; a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ll ans = INF;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		<span class="type">int</span> x = a[i];</span><br><span class="line">		<span class="keyword">while</span> (x) &#123;</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, <span class="built_in">calc</span>(x));</span><br><span class="line">			x &gt;&gt;= <span class="number">1</span>; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> T;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span> (T--) <span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>XCPC解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title>7,8月杂题选做</title>
    <url>/2023/07/18/7,8%E6%9C%88%E6%9D%82%E9%A2%98%E9%80%89%E5%81%9A/</url>
    <content><![CDATA[<h1 id="图论相关">图论相关</h1>
<h2 id="题目来源">题目来源</h2>
<p><a
href="https://atcoder.jp/contests/abc308/tasks/abc308_h">ABC308Ex</a></p>
<h2 id="题意">题意</h2>
<p>给定一张 <span class="math inline">\(n\)</span> 个点 <span
class="math inline">\(m\)</span>
条边的无向带权图，找到图中一个权值最小的 <span
class="math inline">\(\text{Q}\)</span> 。</p>
<p><span class="math inline">\(\text{Q}\)</span>
定义为一个环带上一条与这个环相连且不在环上的边。</p>
<p><span class="math inline">\(4\le n \le 300 , 4\le m \le
\frac{n(n-1)}{2}\)</span> 。</p>
<h2 id="思路">思路</h2>
<p>考虑枚举每一条边作为 <span class="math inline">\(\text{Q}\)</span>
的尾巴，然后把这条边删去，从这条边的一个端点跑一个单源最短路。然后再枚举两个点，能够轻松找到不经过这条边的一个最小环。</p>
<p>这样枚举尾巴的时间复杂度为 <span
class="math inline">\(O(n^2)\)</span> ，找最小环的时间复杂度为 <span
class="math inline">\(O(n^2)\)</span> ，总时间复杂度为 <span
class="math inline">\(O(n^4)\)</span> ，这是难以接受的。</p>
<p>考虑到一个环会占用一个点相连的两条边，最劣情况下尾巴也是第三小的边，所以我们第一步不需要枚举所有的边作为尾巴，只需要枚举每个点相连的前三小的边做尾巴即可。这样枚举尾巴的时间复杂度降为
<span class="math inline">\(O(n)\)</span> ，总时间复杂度降为 <span
class="math inline">\(O(n^3)\)</span> 。</p>
<span id="more"></span>
<h1 id="动态规划">动态规划</h1>
<h2 id="题目来源-1">题目来源</h2>
<p><a
href="https://codeforces.com/problemset/problem/626/F">CF626F</a></p>
<h2 id="题意-1">题意</h2>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的数列 <span
class="math inline">\(a\)</span> ，把 <span
class="math inline">\(a\)</span>
分成任意组，每组的<strong>不和谐度</strong>定义为该组内元组的最大值与最小值之差，求所有<strong>不和谐度</strong>之和不超过
<span class="math inline">\(m\)</span> 的分组方案数，对 <span
class="math inline">\(10^9 + 7\)</span> 取模。</p>
<p><span class="math inline">\(1 \le n \le 200 , 0 \le m \le 10^3 , 1
\le a_i \le 500\)</span> 。</p>
<h2 id="思路-1">思路</h2>
<p>由于<strong>不和谐度</strong>是最大值与最小值的差，乱找不好找，考虑对数列
<span class="math inline">\(a\)</span>
从小到大进行排序，然后依次考虑每个数的分组情况。</p>
<p>考虑设 <span class="math inline">\(f_{i,j,k}\)</span> 为选了前 <span
class="math inline">\(i\)</span> 个位置，有 <span
class="math inline">\(j\)</span> 个没有结束的组，当前选的总不和谐度为
<span class="math inline">\(k\)</span> 的方案数。</p>
<p>考虑若有一个组选了 <span class="math inline">\(a_{p_1} , a_{p_2} ,
\cdots, a_{p_n}\)</span> 这些元素，且 <span class="math inline">\(p_1
&lt; p_2 &lt; \cdots &lt; p_n\)</span> ，则不和谐度为 <span
class="math inline">\(a_{p_n} - a_{p_1}\)</span> 。</p>
<p>考虑到 <span class="math inline">\(a_{p_n} - a_{p_1} = (a_{p_n} -
a_{p_{n-1}}) + (a_{p_{n-1}} - a_{p_{n-2}}) + \cdots + (a_{p_2} -
a_{p_1})\)</span> ，所以每次向之前的某一组中加入 <span
class="math inline">\(a_{i + 1}\)</span> 这个元素时，所有的组都会被增加
<span class="math inline">\(a_{i + 1} - a_{i}\)</span>
的不和谐度，利用这个可以找到转移时 <span
class="math inline">\(k\)</span> 的增量。</p>
<p>再考虑转移的几种情况：</p>
<ul>
<li><p>当前点单独成组：<span class="math inline">\(f_{i + 1 , j , k + j
\times (a_{i + 1} - a_i)} \leftarrow f_{i,j,k}\)</span> 。</p></li>
<li><p>当前点加入一个组中，即不作为最大值，也不作为最小值：<span
class="math inline">\(f_{i + 1, j, k + j \times (a_{i+1} - a_{i})}
\leftarrow f_{i, j, k}\)</span> 。</p></li>
<li><p>当前点新开一个组，且作为最小值：<span class="math inline">\(f_{i
+ 1, j + 1 , k + j \times(a_{i + 1} - a_{i})} \leftarrow
f_{i,j,k}\)</span> 。</p></li>
<li><p>当前点结束一个组，且作为最大值：<span class="math inline">\(f_{i
+ 1, j - 1, k + j \times (a_{i+1}-a_{i})} \leftarrow f_{i,j,k}\)</span>
。</p></li>
</ul>
<p>复杂度可以做到 <span class="math inline">\(O(n^2 m)\)</span> 。</p>
<h2 id="题目来源-2">题目来源</h2>
<p><a
href="https://acjudge.com/d/algorithmbasics/p/773">acjudge#773</a></p>
<h2 id="题意-2">题意</h2>
<p>有 <span class="math inline">\(n\)</span> 个物品和四个盒子 <span
class="math inline">\(A,B,C,D\)</span> ，每个物品都有一个重量 <span
class="math inline">\(w_i\)</span>
，你需要将每个物品放入一个盒子中。</p>
<p>给定 <span class="math inline">\(k_1,k_2,k_3,k_4\)</span> ，设 <span
class="math inline">\(|X|\)</span> 表示 <span
class="math inline">\(X\)</span>
盒子内物品的总重，一个合法的装盒方案最终应当满足如下的条件：</p>
<p><span class="math display">\[
|A|+|B|\le k_1
\]</span></p>
<p><span class="math display">\[
|C|+|D|\le k_2
\]</span></p>
<p><span class="math display">\[
|A|+|C|\le k_3
\]</span></p>
<p><span class="math display">\[
|B|+|D|\le k_4
\]</span></p>
<p>求有多少种合法的装盒方案，答案对 <span
class="math inline">\(998244353\)</span> 取模。</p>
<p><span class="math inline">\(1\le n \le 100 , 1 \le k_i \le
1000\)</span> 。</p>
<h2 id="思路-2">思路</h2>
<p>脑筋慢转弯题（bushi</p>
<p>最直接的思路就是一个四维的背包 <span
class="math inline">\(\text{dp}\)</span> ，设 <span
class="math inline">\(f_{i,a,b,c,d}\)</span> 表示前 <span
class="math inline">\(i\)</span> 件物品，<span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 总共放了 <span
class="math inline">\(a\)</span> ，<span
class="math inline">\(C\)</span> 和 <span
class="math inline">\(D\)</span> 总共放了 <span
class="math inline">\(b\)</span> ，<span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(C\)</span> 总共放了 <span
class="math inline">\(c\)</span> ， <span
class="math inline">\(B\)</span> 和 <span
class="math inline">\(D\)</span> 总共放了 <span
class="math inline">\(d\)</span>
，满足以上限制的总方案数。转移就考虑当前物品放入哪一个箱子。</p>
<p>发现四个盒子两两组合总共有 <span class="math inline">\(6\)</span>
种，但题目中只限制了 <span class="math inline">\(4\)</span>
种，于是找一下关系，不难发现前两个式子加起来是 <span
class="math inline">\(|A| + |B| + |C| + |D|\)</span>
，后两个式子加起来也是 <span class="math inline">\(|A| + |B| + |C| +
|D|\)</span> 。</p>
<p>设 <span class="math inline">\(w_i\)</span> 的前缀和是 <span
class="math inline">\(sum_i\)</span> ，那么到第 <span
class="math inline">\(i\)</span>
个位置，由于每个物品一定会被放入四个盒子其中之一，所以 <span
class="math inline">\(a + c = |A| + |B| + |C| + |D| = sum_i\)</span>
，<span class="math inline">\(b + d = |A| + |B| + |C| + |D| =
sum_i\)</span> ，所以我们找到了 <span class="math inline">\(a,c\)</span>
之间和 <span class="math inline">\(b,d\)</span>
之间的关系，这样可以压掉两维，时间复杂度变成了 <span
class="math inline">\(O(n k ^2)\)</span> 。</p>
]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
</search>
